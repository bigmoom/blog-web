<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="google-site-verification" content="_i0mgfxBy6QPgJZLx5NbYfLAp5i5xqHoSKIcpYOPHM0" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_i0mgfxBy6QPgJZLx5NbYfLAp5i5xqHoSKIcpYOPHM0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.caiwanghui.top","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="图 图的基本知识  相关图片来自Hello算法  图是一种非常重要且常见的数据结构，通常用来表示物与物之间的关系，如果两个物之间存在某种关系，则在图中对应的结点存在边相连。 图由顶点（Vertex）和边（Edge）构成，所以我们可以将图G表示成一组顶点V和一组边E的集合">
<meta property="og:type" content="article">
<meta property="og:title" content="图">
<meta property="og:url" content="http://www.caiwanghui.top/2023/03/01/%E5%9B%BE/index.html">
<meta property="og:site_name" content="菜鸡肥肥的私人博客">
<meta property="og:description" content="图 图的基本知识  相关图片来自Hello算法  图是一种非常重要且常见的数据结构，通常用来表示物与物之间的关系，如果两个物之间存在某种关系，则在图中对应的结点存在边相连。 图由顶点（Vertex）和边（Edge）构成，所以我们可以将图G表示成一组顶点V和一组边E的集合">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123254.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123316.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123946.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301124138.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301124447.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301130700.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301131127.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230302201445.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230302203448.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301142120.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301163332.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301163800.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230302130855.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230302141521.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230302152545.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303132605.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303153103.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230304152157.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230304153524.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303172149.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303172506.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303172849.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303173137.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303173424.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230304131923.png">
<meta property="article:published_time" content="2023-03-01T11:08:01.000Z">
<meta property="article:modified_time" content="2023-03-26T07:15:09.417Z">
<meta property="article:author" content="Wanghui Cai">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123254.png">

<link rel="canonical" href="http://www.caiwanghui.top/2023/03/01/%E5%9B%BE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>图 | 菜鸡肥肥的私人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">菜鸡肥肥的私人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/03/01/%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          图
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-01 11:08:01" itemprop="dateCreated datePublished" datetime="2023-03-01T11:08:01Z">2023-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-26 07:15:09" itemprop="dateModified" datetime="2023-03-26T07:15:09Z">2023-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1>图</h1>
<h2 id="图的基本知识">图的基本知识</h2>
<blockquote>
<p>相关图片来自<a href="https://www.hello-algo.com/chapter_graph/graph/#911" target="_blank" rel="noopener">Hello算法</a></p>
</blockquote>
<p>图是一种非常重要且常见的数据结构，通常用来表示物与物之间的关系，如果两个物之间存在某种关系，则在图中对应的结点存在边相连。</p>
<p>图由顶点（Vertex）和边（Edge）构成，所以我们可以将图<code>G</code>表示成一组顶点<code>V</code>和一组边<code>E</code>的集合</p>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123254.png" style="zoom: 80%;" />
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123316.png" alt=""></p>
<a id="more"></a>
<h3 id="图的常见类型">图的常见类型</h3>
<h4 id="有向图和无向图">有向图和无向图</h4>
<p>图可以分为有向图和无向图，如果给图中每条边规定一个方向，那么这样的图就是有向图，它的边为有向边，如果否则为无向图</p>
<ul>
<li>有向图：只有单向的关系，A\rarr B与B\larr A两个方向的边是相互独立的</li>
<li>无向图：无向图的边没有方向，表示双向的关系，可以看做有两条边</li>
</ul>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123946.png" style="zoom:80%;" />
<h4 id="连通图和非连通图">连通图和非连通图</h4>
<ul>
<li>连通图：从某个顶点出发，可以到达任意剩余顶点</li>
<li>非连通图：从某个顶点出发，至少有有一个顶点无法到达</li>
</ul>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301124138.png" style="zoom:80%;" />
<h4 id="有权图和无权图">有权图和无权图</h4>
<ul>
<li>有权图：边存在权重，表示一种关系程度</li>
<li>无权图：与有权图相反，不存在权重，所有边等价</li>
</ul>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301124447.png" style="zoom:80%;" />
<h3 id="图的表示">图的表示</h3>
<p>图的常见表示方法有两种，分别为<strong>邻接矩阵</strong>和<strong>邻接表</strong></p>
<h4 id="邻接表">邻接表</h4>
<p>邻接表为图中的每个顶点创建一个容器，第<code>i</code>个容器保存所有与第<code>i</code>个顶点相邻的顶点</p>
<p>可以发现，邻接表和散列表非常类似，所以我们也可以与优化散列表一样，当链表过长是改成红黑树</p>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301130700.png" style="zoom:80%;" />
<h4 id="邻接矩阵">邻接矩阵</h4>
<p>如果一个图中有<code>n</code>个结点，那么我们使用一个大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.46528em;"></span><span class="strut bottom" style="height:0.46528em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mbin">∗</span><span class="mord mathit">n</span></span></span></span>的邻接矩阵保存每条边的信息</p>
<p>如果顶点<code>i</code>和顶点<code>j</code>之间有一条边，那么<code>M[i][j]</code>等于1；反之如果没有边，则为0</p>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301131127.png" style="zoom:80%;" />
<p>当然，上面的邻接矩阵表示的是无向图，所以是一个对称矩阵且存在边用1表示，我们也可以用邻接矩阵表示有向图，<code>M[i][j]</code>表示顶点<code>i</code>和顶点<code>j</code>之间的权重</p>
<p>邻接矩阵的查找时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>，但是空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，所以当一个图中顶点数目非常大且比较稀疏的时候邻接矩阵的空间效率就较低，应当选择邻接表。</p>
<h2 id="图的搜索">图的搜索</h2>
<p>和树的搜索一样，图的搜索也分为<strong>广度优先搜索（BFS）<strong>和</strong>深度优先搜索（DFS）</strong></p>
<h3 id="广度优先搜索">广度优先搜索</h3>
<p>广度优先遍历的思路和树的广度优先遍历思路差不多，只不过需要一个散列表或者其他容器记录该顶点是否有被访问过</p>
<ol>
<li>
<p>初始化队列和记录是否访问的散列表</p>
</li>
<li>
<p>开始顶点入队</p>
</li>
<li>
<p>出队，输出该结点</p>
</li>
<li>
<p>遍历出队顶点邻接结点，检查是否访问过</p>
</li>
<li>
<p>没有访问过则入队，否则无需操作</p>
</li>
<li>
<p>重复步骤3-5，直到队列为空</p>
</li>
</ol>
<p>由于每个顶点都会出队入队，使用时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>V</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>，遍历邻接顶点时，由于是无向图所以会被访问两遍，所有边都会被访问两遍，使用时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，总体时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(V+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maze[N][N] = &#123;</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">//使用邻接矩阵进行广度遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">graphBFS</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> startVertex)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(startVertex);</span><br><span class="line">    	visited.add(startVertex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> vertex = queue.poll();</span><br><span class="line">            result.add(vertex);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[vertex].length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[vertex][i]==<span class="number">1</span> &amp;&amp; !visited.contains(i))&#123;</span><br><span class="line">                    visited.add(i);</span><br><span class="line">                    queue.offer(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="深度优先遍历">深度优先遍历</h3>
<p>图的深度优先遍历也和树的深度优先遍历差不多，也是多了检查是否访问过这一步</p>
<blockquote>
<p>我们这里还是直接使用递归的方式实现深度优先遍历，有关迭代方法后面再补充</p>
</blockquote>
<ol>
<li>初始化记录是否访问状态的散列表</li>
<li>输出(开始)顶点，标记(开始)顶点已被访问</li>
<li>遍历顶点所有邻接顶点，对每个顶点转第2步操作（递归）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* int maze[N][N] = &#123;</span></span><br><span class="line"><span class="comment">	&#123; 0, 1, 1, 0, 0 &#125;,</span></span><br><span class="line"><span class="comment">	&#123; 0, 0, 1, 1, 0 &#125;,</span></span><br><span class="line"><span class="comment">	&#123; 0, 1, 1, 1, 0 &#125;,</span></span><br><span class="line"><span class="comment">	&#123; 1, 0, 0, 0, 0 &#125;,</span></span><br><span class="line"><span class="comment">	&#123; 0, 0, 1, 1, 0 &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphDFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result;</span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Integer&gt; visited;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">graphBFS</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> startVertex)</span></span>&#123;</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        visited = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(graph,startVertex);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> vertex)</span></span>&#123;</span><br><span class="line">        result.add(vertex);</span><br><span class="line">        visited.add(vertex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[vertex].length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited.contains(i) &amp;&amp; graph[vertex][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                dfs(graph,graph[vertex][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有顶点都被访问一遍，所有边都被访问两遍，所以时间复杂度还是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(V+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<h3 id="Dijkstra算法">Dijkstra算法</h3>
<p><strong>Dijkstra</strong>算法是非常经典的寻找<strong>单源最短路径</strong>算法，核心思想是贪心广度遍历</p>
<p>基本算法步骤：</p>
<ol>
<li>Dijkstra算法从指定的顶点（源顶点）出发，寻找它与图中其他其他结点之间的最短路径</li>
<li>算法会记录当前已知的最短路径，并在寻找到最短路径的时候更新</li>
<li>一旦找到源节点与其他顶点的最短路径，那么那个顶点会被标记为 <strong>已访问</strong></li>
<li>重复寻找过程，直到所有顶点都添加到路径中，这样就可以得到从源顶点出发到其他所有顶点的最短路径</li>
</ol>
<blockquote>
<p><strong>Dijkstra</strong>算法只能由于权重为正的图中，如果为负权图则无法使用</p>
</blockquote>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230302201445.png" style="zoom:67%;" />
<p>我们以上图为例，想要求得以0为源顶点出发，到达不同顶点的最短距离</p>
<ul>
<li>
<p>初始化顶点距离列表，自己到自己的距离为0，到未知顶点先设置为无限大</p>
Distance = \{0,\infin,\infin,\infin,\infin,\infin,\infin\}

<p>未访问标识列表</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>d</mi><mo>=</mo><mo>{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">Unvisited = \{0,1,2,3,4,5,6\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">3</span><span class="mpunct">,</span><span class="mord mathrm">4</span><span class="mpunct">,</span><span class="mord mathrm">5</span><span class="mpunct">,</span><span class="mord mathrm">6</span><span class="mclose">}</span></span></span></span></span></p>
</li>
<li>
<p>从源顶点出发，未访问中删除0顶点</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>d</mi><mo>=</mo><mo>{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">Unvisited = \{1,2,3,4,5,6\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">3</span><span class="mpunct">,</span><span class="mord mathrm">4</span><span class="mpunct">,</span><span class="mord mathrm">5</span><span class="mpunct">,</span><span class="mord mathrm">6</span><span class="mclose">}</span></span></span></span></span></p>
<p>然后我们发现从0顶点可以到达1顶点和2顶点，距离分别为2和6，将到达1,2距离列表更新</p>
Distance = \{0,2,6,\infin,\infin,\infin,\infin\}

<p>贪心原则，我们取最短的距离，即访问1顶点</p>
</li>
<li>
<p>未访问中删除1顶点</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>d</mi><mo>=</mo><mo>{</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">Unvisited = \{2,3,4,5,6\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">3</span><span class="mpunct">,</span><span class="mord mathrm">4</span><span class="mpunct">,</span><span class="mord mathrm">5</span><span class="mpunct">,</span><span class="mord mathrm">6</span><span class="mclose">}</span></span></span></span></span></p>
<p>从顶点1出发，我们可以到达顶点3，但是距离列表中应该是从源点出发，所以记录的距离是顶点1的距离加上顶点1到顶点3的距离</p>
Distance = \{0,2,6,7,\infin,\infin,\infin\}

<p>可以发现6&lt;7，所以我们访问顶点2</p>
</li>
<li>
<p>未访问中删除2顶点</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>d</mi><mo>=</mo><mo>{</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">Unvisited = \{3,4,5,6\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathrm">3</span><span class="mpunct">,</span><span class="mord mathrm">4</span><span class="mpunct">,</span><span class="mord mathrm">5</span><span class="mpunct">,</span><span class="mord mathrm">6</span><span class="mclose">}</span></span></span></span></span></p>
<p>从顶点2出发，我们又可以到达顶点3，但是由于经过顶点2到顶点3的路径要大于距离列表中的7，所以不做更新，访问顶点3</p>
Distance = \{0,2,6,7,\infin,\infin,\infin\}

</li>
<li>
<p>未访问中删除3顶点</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>d</mi><mo>=</mo><mo>{</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">Unvisited = \{4,5,6\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathrm">4</span><span class="mpunct">,</span><span class="mord mathrm">5</span><span class="mpunct">,</span><span class="mord mathrm">6</span><span class="mclose">}</span></span></span></span></span></p>
<p>从顶点3出发，我们可以到达顶点4，5，更新距离列表</p>
Distance = \{0,2,6,7,17,22,\infin\}

<p>显然，我们继续选择顶点4</p>
</li>
<li>
<p>未访问中删除4顶点</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>d</mi><mo>=</mo><mo>{</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">Unvisited = \{5,6\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathrm">5</span><span class="mpunct">,</span><span class="mord mathrm">6</span><span class="mclose">}</span></span></span></span></span></p>
<p>顶点4出发，我们可以到达顶点5，6,更新距离列表</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>=</mo><mo>{</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>1</mn><mn>7</mn><mo separator="true">,</mo><mn>2</mn><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mn>9</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">Distance = \{0,2,6,7,17,22,19\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">6</span><span class="mpunct">,</span><span class="mord mathrm">7</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mord mathrm">7</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mord mathrm">9</span><span class="mclose">}</span></span></span></span></span></p>
<p>继续选择顶点6</p>
</li>
<li>
<p>未访问中删除6顶点</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>d</mi><mo>=</mo><mo>{</mo><mn>5</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">Unvisited = \{5\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathrm">5</span><span class="mclose">}</span></span></span></span></span></p>
<p>顶点6出发，只有5是还没访问过的了，发现通过顶点6到达顶点5的路径不是最短，所以不做更新，继续访问顶点5</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>=</mo><mo>{</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>1</mn><mn>7</mn><mo separator="true">,</mo><mn>2</mn><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mn>9</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">Distance = \{0,2,6,7,17,22,19\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">6</span><span class="mpunct">,</span><span class="mord mathrm">7</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mord mathrm">7</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mord mathrm">9</span><span class="mclose">}</span></span></span></span></span></p>
</li>
<li>
<p>未访问中删除5顶点</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>d</mi><mo>=</mo><mo>{</mo><mo>}</mo></mrow><annotation encoding="application/x-tex">Unvisited = \{\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mrel">=</span><span class="mopen">{</span><span class="mclose">}</span></span></span></span></span></p>
<p>这个时候所有的顶点都已经访问过了，说明我们已经得到了源点到所有顶点的最短距离</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>=</mo><mo>{</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>1</mn><mn>7</mn><mo separator="true">,</mo><mn>2</mn><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mn>9</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">Distance = \{0,2,6,7,17,22,19\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">6</span><span class="mpunct">,</span><span class="mord mathrm">7</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mord mathrm">7</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mord mathrm">9</span><span class="mclose">}</span></span></span></span></span></p>
</li>
</ul>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230302203448.png" style="zoom:50%;" />
<p>上图中红线即我们的行走路线，可以发现从源顶点到任意一个顶点，都只有唯一红色路径，即最短路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> source)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=source)&#123;</span><br><span class="line">                dist[i]=Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; toBeVisited = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(</span><br><span class="line">                (node1,node2)-&gt;dist[node1]-dist[node2]</span><br><span class="line">        );</span><br><span class="line">        toBeVisited.add(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!toBeVisited.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> node = toBeVisited.poll();</span><br><span class="line">            visited[node]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;graph[node].length;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[node][i]&gt;<span class="number">0</span> &amp;&amp; !visited[i])&#123;</span><br><span class="line">                    dist[i] = Math.min(dist[i],dist[node]+graph[node][i]);</span><br><span class="line">                    <span class="keyword">if</span>(!toBeVisited.contains(i))&#123;</span><br><span class="line">                        toBeVisited.offer(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面我们使用了最小堆来维护待访问结点，这样我们就可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>的时间复杂度获取下一个访问结点</p>
<h3 id="图的搜索的应用">图的搜索的应用</h3>
<p>如果一个题目要求在<strong>无权图</strong>找出两个顶点的<strong>最短距离</strong>，建议使用<strong>广度优先遍历</strong>，如果要找出一条<strong>符合条件的路径</strong>，建议使用<strong>深度优先遍历</strong></p>
<h4 id="最大的岛屿">最大的岛屿</h4>
<blockquote>
<p>LeetCode 695</p>
<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>
<p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>
<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>
<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>
</blockquote>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301142120.png" style="zoom:67%;" />
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">输出：6</span><br><span class="line">解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。</span><br></pre></td></tr></table></figure>
<p>这道题最重要的就是要把题目转化为图的搜索，即每个岛屿就是一个子图，我们就是遍历子图，计算每个子图的顶点数</p>
<p>这里我们遍历整个<code>grid</code>，遇到没有访问过的岛屿，则计算这个岛屿的面积</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">    <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                maxArea = Math.max(maxArea, getArea(grid,visited,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于如何遍历子图顶点，广度遍历和深度遍历都可以</p>
<p>广度遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAreaBFS</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] operations = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span>[] position = queue.poll();</span><br><span class="line">        area++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] operation:operations)&#123;</span><br><span class="line">            <span class="keyword">int</span> adjR = position[<span class="number">0</span>]+operation[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> adjC = position[<span class="number">1</span>]+operation[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(adjR&gt;=<span class="number">0</span> &amp;&amp; adjR&lt;grid.length</span><br><span class="line">                &amp;&amp; adjC&gt;=<span class="number">0</span> &amp;&amp; adjC&lt;grid[<span class="number">0</span>].length</span><br><span class="line">                &amp;&amp; grid[adjR][adjC]==<span class="number">1</span> &amp;&amp; !visited[adjR][adjC])&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;adjR,adjC&#125;);</span><br><span class="line">                visited[adjR][adjC]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>深度遍历</p>
<p>这里我们使用栈实现深度遍历，其实就是将队列替换成了栈，因为栈具有先进后出的特点，所以直接可以实现深度遍历功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAreaDFS</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>[]&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> area=<span class="number">0</span>;</span><br><span class="line">    stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] operations = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span>[] location = stack.pop();</span><br><span class="line">        area++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] operation:operations)&#123;</span><br><span class="line">            <span class="keyword">int</span> adjR = location[<span class="number">0</span>]+operation[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> adjC = location[<span class="number">1</span>] + operation[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(adjR&gt;=<span class="number">0</span> &amp;&amp; adjR&lt;grid.length</span><br><span class="line">                &amp;&amp;adjC&gt;=<span class="number">0</span>&amp;&amp;adjC&lt;grid[<span class="number">0</span>].length</span><br><span class="line">                &amp;&amp;grid[adjR][adjC]==<span class="number">1</span> &amp;&amp; !visited[adjR][adjC])&#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;adjR,adjC&#125;);</span><br><span class="line">                visited[adjR][adjC]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分图">二分图</h4>
<blockquote>
<p>LeetCode 785</p>
<p>存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。给你一个二维数组 <code>graph</code> ，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于 <code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：</p>
<ul>
<li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li>
<li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li>
<li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li>
<li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li>
</ul>
<p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p>
<p>如果图是二分图，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
</blockquote>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301163332.png" style="zoom:67%;" />
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,2,3],[0,2],[0,1,3],[0,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。</span><br></pre></td></tr></table></figure>
<p>这一题乍一看跟遍历没什么关系，但我们可以将题目进行转化</p>
<p>我们对图中顶点进行遍历并上色，然后检查邻接顶点有没有上色，如果没有上色则上另一种颜色，如果有邻接顶点颜色与该顶点相同，则说明违法了二分图的规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = graph.length;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">int</span> color = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//initial color</span></span><br><span class="line">    Arrays.fill(colors,-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(colors[i]==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!setColorBFS(graph,i,colors,color))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setColorBFS</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> index,<span class="keyword">int</span>[] colors,<span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(index);</span><br><span class="line">    colors[index] = color;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> point = queue.poll();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> adj:graph[point])&#123;</span><br><span class="line">            <span class="keyword">if</span>(colors[adj]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(colors[adj]==colors[point])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                queue.offer(adj);</span><br><span class="line">                colors[adj] = <span class="number">1</span>-colors[point];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setColorDFS</span><span class="params">(<span class="keyword">int</span>[][] graph,<span class="keyword">int</span> index,<span class="keyword">int</span>[] colors,<span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(colors[index]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> colors[index]==color;</span><br><span class="line">    &#125;</span><br><span class="line">    colors[index] = color;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> adj:graph[index])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!setColorDFS(graph,adj,colors,<span class="number">1</span>-color))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="矩阵中的距离">矩阵中的距离</h4>
<blockquote>
<p>LeetCode 542</p>
<p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>mat</code> ，请输出一个大小相同的矩阵，其中每一个格子是 <code>mat</code> 中对应位置元素到最近的 <code>0</code> 的距离。</p>
<p>两个相邻元素间的距离为 <code>1</code> 。</p>
</blockquote>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301163800.png" style="zoom:80%;" />
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat &#x3D; [[0,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">输出：[[0,0,0],[0,1,0],[1,2,1]]</span><br></pre></td></tr></table></figure>
<p>这道题直觉思路就是遍历每一个为1的元素，对其进行广度遍历，找到距离最短的0，但是这样的开销实在是太大了，不太现实</p>
<p>其实这道题是一到经典的<strong>多源广度遍历</strong>的问题，我们不再是以一个点为开始顶点，而是一群点作为第一行，然后第一行中的每一个找到下一行的元素，类似于树中遍历完这一层再遍历下一层</p>
<ul>
<li>这道题中我们就以值为0的顶点为第一层，把所有为0的顶点入队，并且距离设置为0</li>
<li>出队，检查上下左右邻接顶点是否被读过，如果没有读过，则距离+1并入队</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] mat) &#123;</span><br><span class="line">      Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[mat.length][mat[<span class="number">0</span>].length];</span><br><span class="line"><span class="comment">//不要用hashset，会超时        </span></span><br><span class="line">      <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[mat.length][mat[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mat.length;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;mat[i].length;j++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(mat[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                  dist[i][j]=<span class="number">0</span>;</span><br><span class="line">                  queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                  seen[i][j] = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span>[][] operations = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">int</span>[] position = queue.poll();</span><br><span class="line">          <span class="keyword">int</span> row = position[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">int</span> col = position[<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span>[] operation:operations)&#123;</span><br><span class="line">              <span class="keyword">int</span> newR = row+operation[<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">int</span> newC = col+operation[<span class="number">1</span>];</span><br><span class="line">              <span class="keyword">if</span>(newR&gt;=<span class="number">0</span>&amp;&amp;newC&gt;=<span class="number">0</span>&amp;&amp;newC&lt;mat[<span class="number">0</span>].length&amp;&amp;newR&lt;mat.length &amp;&amp;!seen[newR][newC])&#123;</span><br><span class="line">                  dist[newR][newC] = dist[row][col]+<span class="number">1</span>;</span><br><span class="line">                  queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newR,newC&#125;);</span><br><span class="line">                  seen[newR][newC]=<span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dist;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="单词演变">单词演变</h4>
<blockquote>
<p>LeetCode 127</p>
<p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p>
<ul>
<li>每一对相邻的单词只差一个字母。</li>
<li>对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在 <code>wordList</code> 中。注意， <code>beginWord</code> 不需要在 <code>wordList</code> 中。</li>
<li><code>sk == endWord</code></li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 <code>0</code> 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure>
<p>这道题虽然说是一道<code>Hard</code>的题，但是转换之后就很简单</p>
<p>我们可以把<code>wordlist</code>里面的单词当做顶点，每个相邻的顶点构建一条边（题目中要求的字母相差一位），那么这道题其实就是无向图中求最短路径，所以我们可以直接使用广度优先遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    Queue&lt;String&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; notVisited = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line"></span><br><span class="line">    queue1.offer(beginWord);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        String word = queue1.poll();</span><br><span class="line">        <span class="keyword">if</span> (word.equals(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; adjWords = getAdjWords(word,notVisited);</span><br><span class="line">        <span class="keyword">for</span> (String adjWord : adjWords) &#123;</span><br><span class="line">            queue2.offer(adjWord);</span><br><span class="line">            notVisited.remove(adjWord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getAdjWords</span><span class="params">(String word,Set&lt;String&gt; notVisited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">    List&lt;String&gt; adjWords = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> char1 = chars[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'a'</span>;ch&lt;=<span class="string">'z'</span>;++ch)&#123;</span><br><span class="line">            <span class="keyword">if</span>(char1!=ch)&#123;</span><br><span class="line">                chars[i] = ch;</span><br><span class="line">                <span class="keyword">if</span>(notVisited.contains(String.valueOf(chars)))&#123;adjWords.add(String.valueOf(chars));&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chars[i] = char1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> adjWords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们使用了两个队列，也是类似于记录区别每一层的，这里是用来记录路径的长度</p>
<p>对于题目这种单一起点，单一目标的广度遍历，我们可以使用双向广度遍历进行优化，即从起点和目标顶点同时进行广度遍历，直到某个方向的搜索与另一方向有重合即可终止，这样的双向搜索的方法能大大节省搜索空间，提高搜索效率</p>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230302130855.png" style="zoom: 67%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLengthBidirectionalBFS</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</span><br><span class="line">    Set&lt;String&gt; notVisited = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    Set&lt;String&gt; wordListSet =  <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    <span class="keyword">if</span>(!notVisited.contains(endWord))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; frontSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; endSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    frontSet.add(beginWord);</span><br><span class="line">    endSet.add(endWord);</span><br><span class="line">    notVisited.remove(endWord);</span><br><span class="line">    <span class="keyword">while</span>(!frontSet.isEmpty() &amp;&amp; !endSet.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//choose the smaller set to search</span></span><br><span class="line">        <span class="keyword">if</span>(frontSet.size()&gt;endSet.size())&#123;</span><br><span class="line">            Set&lt;String&gt; tempSet = endSet;</span><br><span class="line">            endSet = frontSet;</span><br><span class="line">            frontSet = tempSet;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; adjSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String word:frontSet)&#123;</span><br><span class="line">            List&lt;String&gt; adjWords = getAdjWords(word,wordListSet);</span><br><span class="line">            <span class="keyword">for</span>(String adjWord:adjWords)&#123;</span><br><span class="line">                <span class="keyword">if</span> (endSet.contains(adjWord))&#123;</span><br><span class="line">                    <span class="keyword">return</span> length;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(notVisited.contains(adjWord))&#123;</span><br><span class="line">                    adjSet.add(adjWord);</span><br><span class="line">                    notVisited.remove(adjWord);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        length++;</span><br><span class="line">        frontSet = adjSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们使用了三个<code>HashSet</code>来替代队列，其中每次迭代之前比较首尾两个<code>Set</code>的大小，每次从小的顶点遍历，这样能更加优化搜索效率</p>
<h4 id="开密码锁">开密码锁</h4>
<blockquote>
<p>LeetCode 752</p>
<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code> 。每个拨轮可以自由旋转：例如把 <code>'9'</code> 变为 <code>'0'</code>，<code>'0'</code> 变为 <code>'9'</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>锁的初始数字为 <code>'0000'</code> ，一个代表四个拨轮的数字的字符串。</p>
<p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>
<p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 <code>-1</code> 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：deadends &#x3D; [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target &#x3D; &quot;0202&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。</span><br><span class="line">注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，</span><br><span class="line">因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure>
<p>这道题其实很简答，很明显就是一个广度遍历问题，每转动一个拨轮对应一个新的状态，那么一个状态就对应八个新的状态，层层遍历直到达到目标状态即可</p>
<p>此外，这道题也是单起始点，单目标点，仍然可以使用双向广度遍历优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; frontSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; endSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; deadSequences = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(deadends));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(deadSequences.contains(START_SEQUENCE))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target.equals(START_SEQUENCE))&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">        frontSet.add(START_SEQUENCE);</span><br><span class="line">        endSet.add(target);</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!frontSet.isEmpty() &amp;&amp; !endSet.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(endSet.size()&lt;frontSet.size())&#123;</span><br><span class="line">                Set&lt;String&gt; tempSet = endSet;</span><br><span class="line">                endSet = frontSet;</span><br><span class="line">                frontSet = tempSet;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set&lt;String&gt; adjSequencesSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String sequence:frontSet)&#123;</span><br><span class="line">                List&lt;String&gt; adjSequences = getAdjSequence(sequence);</span><br><span class="line">                <span class="keyword">for</span>(String adjSequence:adjSequences)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(endSet.contains(adjSequence))&#123;</span><br><span class="line">                        <span class="keyword">return</span> length;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(adjSequence) &amp;&amp; !deadSequences.contains(adjSequence))&#123;</span><br><span class="line">                        visited.add(adjSequence);</span><br><span class="line">                        adjSequencesSet.add(adjSequence);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            frontSet = adjSequencesSet;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getAdjSequence</span><span class="params">(String sequence)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; adjSequences = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] nums = sequence.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">char</span> oldChar = nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> newChar = oldChar==<span class="string">'0'</span>?<span class="string">'9'</span>: (<span class="keyword">char</span>)(oldChar-<span class="number">1</span>);</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder(sequence);</span><br><span class="line">            builder.setCharAt(i,newChar);</span><br><span class="line">            adjSequences.add(builder.toString());</span><br><span class="line"></span><br><span class="line">            newChar = oldChar==<span class="string">'9'</span>?<span class="string">'0'</span>: (<span class="keyword">char</span>)(oldChar+<span class="number">1</span>);</span><br><span class="line">            builder.setCharAt(i, newChar);</span><br><span class="line">            adjSequences.add(builder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adjSequences;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="所有路径">所有路径</h4>
<blockquote>
<p>LeetCode 797</p>
<p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p><code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p>
</blockquote>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230302141521.png" style="zoom:67%;" />
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure>
<p>这道题需要找到<code>0</code>到<code>n-1</code>的所有路径，所以使用深度优先遍历更加方便</p>
<p>此外，由于是有向无环图，所以不需要记录结点是否访问过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>,graph,path,result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span>[][] graph,List&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; result)</span></span>&#123;</span><br><span class="line">    path.add(node);</span><br><span class="line">    <span class="keyword">if</span>(node==graph.length-<span class="number">1</span>)&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> adj:graph[node])&#123;</span><br><span class="line">            dfs(adj,graph,path,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算除法">计算除法</h4>
<blockquote>
<p>LeetCode 399</p>
<p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p>
<p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p>
<p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p>
<p>**注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：equations &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values &#x3D; [2.0,3.0], queries &#x3D; [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span><br><span class="line">输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class="line">解释：</span><br><span class="line">条件：a &#x2F; b &#x3D; 2.0, b &#x2F; c &#x3D; 3.0</span><br><span class="line">问题：a &#x2F; c &#x3D; ?, b &#x2F; a &#x3D; ?, a &#x2F; e &#x3D; ?, a &#x2F; a &#x3D; ?, x &#x2F; x &#x3D; ?</span><br><span class="line">结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br></pre></td></tr></table></figure>
<p>这道题其实就是有向有权图的遍历问题，例如上例我们计算<code>a/c</code>，其实就是找到<code>a-b-c</code>这样的一条路径，并计算路径权重的积</p>
<p>所以我们只需要构建好图，然后进行深度遍历即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">    Map&lt;String, Map&lt;String,Double&gt;&gt; graph = buildGraph(equations,values);</span><br><span class="line">    <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.size();++i) &#123;</span><br><span class="line">        List&lt;String&gt; query = queries.get(i);</span><br><span class="line">        String start =query.get(<span class="number">0</span>);</span><br><span class="line">        String end = query.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!graph.containsKey(start) || !graph.containsKey(end))&#123;</span><br><span class="line">            result[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            result[i] = dfs(graph,visited,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Map&lt;String,Double&gt;&gt; buildGraph(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Map&lt;String,Double&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.size();++i)&#123;</span><br><span class="line">        String front = equations.get(i).get(<span class="number">0</span>);</span><br><span class="line">        String end = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        graph.putIfAbsent(front,<span class="keyword">new</span> HashMap&lt;String,Double&gt;());</span><br><span class="line">        graph.get(front).put(end,values[i]);</span><br><span class="line"></span><br><span class="line">        graph.putIfAbsent(end,<span class="keyword">new</span> HashMap&lt;String,Double&gt;());</span><br><span class="line">        graph.get(end).put(front,<span class="number">1</span>/values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">dfs</span><span class="params">(Map&lt;String, Map&lt;String,Double&gt;&gt; graph,Set&lt;String&gt; visited,String start,String end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start.equals(end))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Double&gt; entry:graph.get(start).entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited.contains(entry.getKey()))&#123;</span><br><span class="line">                <span class="keyword">double</span> nextValue = dfs(graph, visited, entry.getKey(), end);</span><br><span class="line">                <span class="keyword">if</span>(nextValue&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> entry.getValue()*nextValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited.remove(start);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长递增路径">最长递增路径</h4>
<blockquote>
<p>LeetCode 329</p>
<p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p>
</blockquote>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230302152545.png" style="zoom:67%;" />
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[9,9,4],[6,6,8],[2,1,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure>
<p>这道题很明显还是遍历问题，这里是有向图，由小顶点指向大顶点，并且可以发现肯定是有向无环图</p>
<p>涉及到记录路径问题，我们还是选用深度遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, List&lt;<span class="keyword">int</span>[]&gt;&gt; graph = buildMap(matrix);</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] lengths = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> length = dfs(graph,i,j,lengths);</span><br><span class="line">                longest = Math.max(length,longest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Map&lt;String, List&lt;<span class="keyword">int</span>[]&gt;&gt; buildMap(<span class="keyword">int</span>[][] matrix)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        Map&lt;String,List&lt;<span class="keyword">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] operations = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;++j)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] position = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                graph.put(Arrays.toString(position),<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">                <span class="keyword">int</span> row = position[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> col = position[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> value = matrix[row][col];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] operation:operations)&#123;</span><br><span class="line">                    <span class="keyword">int</span> newRow = row+operation[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> newCol = col+operation[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(newRow&gt;=<span class="number">0</span>&amp;&amp;newCol&gt;=<span class="number">0</span>&amp;&amp;newRow&lt;rows&amp;&amp;newCol&lt;cols&amp;&amp;matrix[newRow][newCol]&gt;value)&#123;</span><br><span class="line">                        graph.get(Arrays.toString(position)).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newRow,newCol&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Map&lt;String, List&lt;<span class="keyword">int</span>[]&gt;&gt; graph,<span class="keyword">int</span> rIndex,<span class="keyword">int</span> cIndex,<span class="keyword">int</span>[][] lengths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lengths[rIndex][cIndex]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> lengths[rIndex][cIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; adjNodes = graph.get(Arrays.toString(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;rIndex,cIndex&#125;) );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(adjNodes.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] adjNode:adjNodes)&#123;</span><br><span class="line">            <span class="keyword">int</span> path = dfs(graph,adjNode[<span class="number">0</span>],adjNode[<span class="number">1</span>],lengths);</span><br><span class="line">            length = Math.max(path+<span class="number">1</span>,length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lengths[rIndex][cIndex]=length;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树问题">最小生成树问题</h2>
<p>一个无向图G的最小生成树是有该图的那些连接G的所有顶点的边构成的树，且其总权重最低</p>
<p>这里介绍两种最常见的最小生成树的算法，<strong>Prim</strong>算法和 <strong>Kruskal</strong>算法，他们的区别主要在最小（值的）边如何选取上面</p>
<h3 id="Prim算法">Prim算法</h3>
<p>又称”加点法“，在算法的任意时刻，我们都可以看到一组已经添加到树上的顶点，和其余未添加到树上的顶点，算法每次迭代便是选择树上顶点到未上树顶点组成的边中权重最小的边对应的点加入到最小生成树中，这样从一个顶点开始逐渐覆盖到整个图</p>
<ul>
<li>设图的顶点集合为<code>V</code>，初始化生成树顶点集合<code>U={u}</code>，未上树顶点集合<code>S={V-u}</code></li>
<li>在集合<code>U</code>和集合<code>S</code>中元素一一对应组成的边中选择一条权重最小的边<code>(u0,s0)</code>加入最小生成树中，并把<code>s0</code>加入到集合<code>U</code>中</li>
<li>重复上述步骤直到所有顶点都被加入最小生成树</li>
</ul>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303132605.png" style="zoom:67%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] graph = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    prim(graph);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span>[][] graph)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = graph.length;</span><br><span class="line">    <span class="keyword">int</span>[][] MST = <span class="keyword">new</span> <span class="keyword">int</span>[size][size];</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; unvisited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</span><br><span class="line">        unvisited.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set node 0 be root</span></span><br><span class="line">    visited.add(<span class="number">0</span>);</span><br><span class="line">    unvisited.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size-<span class="number">1</span>;++j)&#123;</span><br><span class="line">        <span class="keyword">int</span> node1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> node2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> visitedInd:visited)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> unVisitedIndex:unvisited)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[visitedInd][unVisitedIndex]!=<span class="number">0</span> &amp;&amp; graph[visitedInd][unVisitedIndex]&lt;len)&#123;</span><br><span class="line">                    len = graph[visitedInd][unVisitedIndex];</span><br><span class="line">                    node1 = visitedInd;</span><br><span class="line">                    node2 = unVisitedIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.add(node2);</span><br><span class="line">        unvisited.remove(node2);</span><br><span class="line">        MST[node1][node2] = graph[node1][node2];</span><br><span class="line">        MST[node2][node1] = graph[node2][node1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] data:MST)&#123;</span><br><span class="line">        System.out.println(Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal算法">Kruskal算法</h3>
<p>又称“加边法”，初始生成边的个数为0，依次寻找权重最小的边，并且保证边的两个顶点没有在同一个子树上，符合条件的边便可以加入树</p>
<ul>
<li>把图中的所有边按大小排序</li>
<li>按权重从小到达选择边，检查边的两个端点是否符合两个顶点没有在同一个子树上，如果符合条件则插入边</li>
<li>重复上述步骤直到所有顶点都加入最小生成树</li>
</ul>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303153103.png" style="zoom:67%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kruskal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] graph = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        kruskal(graph);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node1;</span><br><span class="line">        <span class="keyword">int</span> node2;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        Edge(<span class="keyword">int</span> node1,<span class="keyword">int</span> node2,<span class="keyword">int</span> value)&#123;</span><br><span class="line">            <span class="keyword">this</span>.node1=node1;</span><br><span class="line">            <span class="keyword">this</span>.node2 = node2;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span>[][] graph)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Edge&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">                (edge1,edge2) -&gt; edge1.value-edge2.value</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//use union-find</span></span><br><span class="line">        <span class="keyword">int</span>[] fathers = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fathers.length;++i)&#123;</span><br><span class="line">            fathers[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; edgeInHeap = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] MST = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length][graph[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graph.length;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    String edgeString = Arrays.toString(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                    String edgeStringReversed = Arrays.toString(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;j, i&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(!edgeInHeap.contains(edgeString) &amp;&amp; !edgeInHeap.contains(edgeStringReversed))&#123;</span><br><span class="line">                        edgeInHeap.add(edgeString);</span><br><span class="line">                        minHeap.offer(<span class="keyword">new</span> Edge(i,j,graph[i][j]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.length;++i)&#123;</span><br><span class="line">            Edge edge = minHeap.poll();</span><br><span class="line">            <span class="keyword">int</span> node1 = edge.node1;</span><br><span class="line">            <span class="keyword">int</span> node2 = edge.node2;</span><br><span class="line">            <span class="keyword">if</span>(!union(node1,node2,fathers))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;fathers.length;++j)&#123;</span><br><span class="line">                    fathers[j]=fathers[j]==fathers[node2]?fathers[node1]:fathers[j];</span><br><span class="line">                &#125;</span><br><span class="line">                MST[node1][node2] = edge.value;</span><br><span class="line">                MST[node2][node1] = edge.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span>[] fathers,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fathers[i]!=i)&#123;</span><br><span class="line">            fathers[i] = findFather(fathers,fathers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fathers[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> node1,<span class="keyword">int</span> node2,<span class="keyword">int</span>[] fathers)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node1Father = findFather(fathers,node1);</span><br><span class="line">        <span class="keyword">int</span> node2Father = findFather(fathers,node2);</span><br><span class="line">        <span class="keyword">return</span> node1Father==node2Father;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面关于如何判断两个顶点是不是在一个子树上，使用了并查集进行判断，具体关于并查集的内容详看最后一张</p>
<h2 id="拓扑排序">拓扑排序</h2>
<h3 id="拓扑排序的基础知识">拓扑排序的基础知识</h3>
<p>拓扑排序其实就是指对一个<strong>有向无环图</strong>的顶点进行排序之后得到的序列，该序列需要保持下面两个条件</p>
<ul>
<li>每个顶点出现且仅出现一次</li>
<li>若存在一条从顶点A到顶点B的路径，那么在序列中顶点A出现在B的前面</li>
</ul>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230304152157.png" style="zoom:67%;" />
<p>我们以上图为例，上图是一个有向无环图，所以可以构建拓扑排序</p>
<p>我们首先要熟悉两个概念，入度和出度：</p>
<ul>
<li>入度：顶点v的入度指的是以顶点v为终点的边的个数，例如上图顶点4的入度就是2，1的入度就是0</li>
<li>出度：顶点v的出度指的是以顶点v为起点的边的个数，例如上图顶点1的出度就是2，4的出度也是2</li>
</ul>
<p>接下来我们来看拓扑排序的步骤</p>
<ul>
<li>找到当前图中入度为0的顶点并输出</li>
<li>删除该顶点以及以他为起点的边</li>
<li>重复上述操作直到当前图为空或者当前图中不存在入度为0的顶点，后者说明图中必有环</li>
</ul>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230304153524.png" style="zoom:67%;" />
<h3 id="拓扑排序的应用">拓扑排序的应用</h3>
<h4 id="课程顺序">课程顺序</h4>
<blockquote>
<p>LeetCode 210</p>
<p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p>
<ul>
<li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li>
</ul>
<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses &#x3D; 4, prerequisites &#x3D; [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出：[0,2,1,3]</span><br><span class="line">解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure>
<p>这道题就是最典型的使用拓扑排序的例子</p>
<p>我们把每节课通过前置关系连接起来其实就是一个有向图，并且需要按照前置这种顺序排序，所以我们可以使用一个队列，把所有入度为0的入队，然后依次出队，相邻顶点入度减一，更新队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            graph.put(i, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] inDegrees = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites)&#123;</span><br><span class="line">            graph.get(pre[<span class="number">1</span>]).add(pre[<span class="number">0</span>]);</span><br><span class="line">            inDegrees[pre[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inDegrees.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegrees[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">            result.add(course);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> nextCourse:graph.get(course))&#123;</span><br><span class="line">                inDegrees[nextCourse]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegrees[nextCourse]==<span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(nextCourse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.size()==numCourses?result.stream().mapToInt(i-&gt;i).toArray():<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="外星文字典">外星文字典</h4>
<blockquote>
<p>LeetCode 269</p>
<p>现有一种使用英语字母的火星语言，这门语言的字母顺序与英语顺序不同。</p>
<p>给你一个字符串列表 <code>words</code> ，作为这门语言的词典，<code>words</code> 中的字符串已经 <strong>按这门新语言的字母顺序进行了排序</strong> 。</p>
<p>请你根据该词典还原出此语言中已知的字母顺序，并 <strong>按字母递增顺序</strong> 排列。若不存在合法字母顺序，返回 <code>&quot;&quot;</code> 。若存在多种可能的合法字母顺序，返回其中 <strong>任意一种</strong> 顺序即可。</p>
<p>字符串 <code>s</code> <strong>字典顺序小于</strong> 字符串 <code>t</code> 有两种情况：</p>
<ul>
<li>在第一个不同字母处，如果 <code>s</code> 中的字母在这门外星语言的字母顺序中位于 <code>t</code> 中字母之前，那么 <code>s</code> 的字典顺序小于 <code>t</code> 。</li>
<li>如果前面 <code>min(s.length, t.length)</code> 字母都相同，那么 <code>s.length &lt; t.length</code> 时，<code>s</code> 的字典顺序也小于 <code>t</code> 。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]</span><br><span class="line">输出：&quot;wertf&quot;</span><br></pre></td></tr></table></figure>
<p>这道题还是比较难的，一眼可能看不出什么思路，但是仔细比较发现，我们其实可以把字典顺序转化为图的边，例如<code>wrt</code>在<code>wrf</code>前面是因为<code>t</code>在<code>f</code>前面，所以我们可以构造一条有向边，由<code>t</code>指向<code>r</code>，然后扫描整个列表，构建出一个有向图，那么我们要得到的其实就是这个图的拓扑排序序列，这样题目就非常简单了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; inDegrees = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">            graph.putIfAbsent(ch, <span class="keyword">new</span> HashSet&lt;Character&gt;());</span><br><span class="line">            inDegrees.putIfAbsent(ch, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.length; ++i) &#123;</span><br><span class="line">        String word1 = words[i - <span class="number">1</span>];</span><br><span class="line">        String word2 = words[i];</span><br><span class="line">        <span class="comment">//Illegal</span></span><br><span class="line">        <span class="keyword">if</span> (word1.startsWith(word2) &amp;&amp; !word1.equals(word2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word1.length() &amp;&amp; j &lt; word2.length(); ++j)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = word1.charAt(j);</span><br><span class="line">            <span class="keyword">char</span> ch2 = word2.charAt(j);</span><br><span class="line">            <span class="keyword">if</span>(ch1!=ch2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!graph.get(ch1).contains(ch2))&#123;</span><br><span class="line">                    graph.get(ch1).add(ch2);</span><br><span class="line">                    inDegrees.put(ch2,inDegrees.get(ch2)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Character,Integer&gt; entry:inDegrees.entrySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(entry.getValue()==<span class="number">0</span>)&#123;</span><br><span class="line">            queue.offer(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = queue.poll();</span><br><span class="line">        sb.append(ch);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> nextCh:graph.get(ch))&#123;</span><br><span class="line">            inDegrees.put(nextCh,inDegrees.get(nextCh)-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(inDegrees.get(nextCh)==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(nextCh);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.length()==graph.size()?sb.toString():<span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重建序列">重建序列</h4>
<blockquote>
<p>LeetCode 444</p>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 是范围为 <code>[1，n]</code> 的整数的排列。还提供了一个 2D 整数数组 <code>sequences</code> ，其中 <code>sequences[i]</code> 是 <code>nums</code> 的子序列。<br>
检查 <code>nums</code> 是否是唯一的最短 <strong>超序列</strong> 。最短 <strong>超序列</strong> 是 <strong>长度最短</strong> 的序列，并且所有序列 <code>sequences[i]</code> 都是它的子序列。对于给定的数组 <code>sequences</code> ，可能存在多个有效的 <strong>超序列</strong> 。</p>
<ul>
<li>例如，对于 <code>sequences = [[1,2],[1,3]]</code> ，有两个最短的 <strong>超序列</strong> ，<code>[1,2,3]</code> 和 <code>[1,3,2]</code> 。</li>
<li>而对于 <code>sequences = [[1,2],[1,3],[1,2,3]]</code> ，唯一可能的最短 <strong>超序列</strong> 是 <code>[1,2,3]</code> 。<code>[1,2,3,4]</code> 是可能的超序列，但不是最短的。</li>
</ul>
<p><em>如果 <code>nums</code> 是序列的唯一最短 <strong>超序列</strong> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</em><br>
<strong>子序列</strong> 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3], sequences &#x3D; [[1,2],[1,3]]</span><br><span class="line">输出：false</span><br><span class="line">解释：有两种可能的超序列：[1,2,3]和[1,3,2]。</span><br><span class="line">序列 [1,2] 是[1,2,3]和[1,3,2]的子序列。</span><br><span class="line">序列 [1,3] 是[1,2,3]和[1,3,2]的子序列。</span><br><span class="line">因为 nums 不是唯一最短的超序列，所以返回false。</span><br></pre></td></tr></table></figure>
<p>这道题题目有点难懂，其实子序列就是超序列中元素顺序不变的子集，然后判断我们能不能通过这些子序列还原的最短超序列是不是唯一且与输入相等</p>
<p>其实我们画个图就很明白了，例如上面的<code>[1,2],[1,3]</code>，1指向2，1指向3，那么他们的拓扑排序不唯一，可能为123,也可能是132</p>
<p>所以这道题就是构建图，然后对图进行拓扑排序，判断拓扑排序是否唯一</p>
<p>判断拓扑排序是否唯一其实很简单，就是判断每次迭代都只有一个入度为0的顶点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sequenceReconstruction</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; sequences)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; sequence : sequences) &#123;</span><br><span class="line">          <span class="keyword">for</span>(Integer num:sequence)&#123;</span><br><span class="line">              graph.putIfAbsent(num,<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">              inDegree.putIfAbsent(num,<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sequence.size();++i)&#123;</span><br><span class="line">              <span class="keyword">int</span> num1 = sequence.get(i-<span class="number">1</span>);</span><br><span class="line">              <span class="keyword">int</span> num2 = sequence.get(i);</span><br><span class="line">              <span class="keyword">if</span>(!graph.get(num1).contains(num2))&#123;</span><br><span class="line">                  graph.get(num1).add(num2);</span><br><span class="line">                  inDegree.put(num2,inDegree.get(num2)+<span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:inDegree.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree.get(num)==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> num = queue.poll();</span><br><span class="line">            result.add(num);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> nextNum:graph.get(num))&#123;</span><br><span class="line">                inDegree.put(nextNum,inDegree.get(nextNum)-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(inDegree.get(nextNum)==<span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(nextNum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] resultArray = result.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(resultArray,nums);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集">并查集</h2>
<h3 id="并查集的基本知识">并查集的基本知识</h3>
<p>并查集是用来表示不相交集合的一种特殊的数据结构，一般用来判断图内顶点是否连通问题</p>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303172149.png" style="zoom:67%;" />
<p>例如上图所示，我们有<code>0,1,2,3,4,5,6,7</code>这几个结点，但是<code>1,2,0,4</code>属于一个子集，<code>6,3,7</code>属于一个子集，<code>5</code>自己也是一个子集，子集之间互不相交</p>
<p>并查集支持两种操作，合并和查找</p>
<ul>
<li>
<p>合并</p>
<p>合并是指将两个子集合并成一个子集，我们只需要将一个子集的根结点指向另一个子集的根结点即可</p>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303172506.png" style="zoom:67%;" />
</li>
<li>
<p>查找</p>
<p>即确定某个元素位于哪个子集当中</p>
<p>并查集以根结点作为子集的标识，相同子集的元素有相同的根结点，如果两个元素的根结点不同则属于同一结点</p>
</li>
</ul>
<p>对于查询，我们可以进行路径压缩</p>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303172849.png" style="zoom:67%;" />
<p>例如我们有如上的一个并查集，那么我们查询结点4的根结点需要依次查找结点3，结点2，结点1，结点0的根结点，查询之后我们已经知道4,3,2,1,0的根结点都是0，那么我们不希望下次查询的时候还要遍历，所以直接记录每个结点的根结点，并在初次查询之后更新根结点</p>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303173137.png" style="zoom:67%;" />
<h3 id="并查集的应用">并查集的应用</h3>
<p>并查集一般用来解决图中子图数目是多少？最大的子图有多少个顶点？这些类似的问题</p>
<h4 id="朋友圈问题-省份数量">朋友圈问题/省份数量</h4>
<blockquote>
<p>LeetCode 547</p>
<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>
<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>
<p>返回矩阵中 <strong>省份</strong> 的数量。</p>
</blockquote>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230303173424.png" style="zoom:67%;" />
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p>这道题我们可以先不使用并查集，直接使用广度遍历，因为是非强连通图，所以我们只需要记录能进行多少次遍历即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[isConnected.length];</span><br><span class="line">    <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isConnected.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            bfs(isConnected,visited,i);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] isConnected, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;isConnected[i].length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isConnected[node][i]==<span class="number">1</span> &amp;&amp; !visited[i])&#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                visited[i]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们使用并查集来处理子图问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] fathers = <span class="keyword">new</span> <span class="keyword">int</span>[isConnected.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isConnected.length; ++i) &#123;</span><br><span class="line">            fathers[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = fathers.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;isConnected.length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;isConnected[i].length;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j]==<span class="number">1</span> &amp;&amp; union(fathers,i,j))&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFather</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fathers[i] != i) &#123;</span><br><span class="line">            fathers[i] = getFather(fathers, fathers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fathers[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fatherOfI = getFather(fathers,i);</span><br><span class="line">        <span class="keyword">int</span> fatherOfJ = getFather(fathers,j);</span><br><span class="line">        <span class="keyword">if</span>(fatherOfI!=fatherOfJ)&#123;</span><br><span class="line">            fathers[fatherOfJ] = fatherOfI;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="相似的字符串">相似的字符串</h4>
<blockquote>
<p>LeetCode 839</p>
<p>如果交换字符串 <code>X</code> 中的两个不同位置的字母，使得它和字符串 <code>Y</code> 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p>
<p>例如，<code>&quot;tars&quot;</code> 和 <code>&quot;rats&quot;</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)； <code>&quot;rats&quot;</code> 和 <code>&quot;arts&quot;</code> 也是相似的，但是 <code>&quot;star&quot;</code> 不与 <code>&quot;tars&quot;</code>，<code>&quot;rats&quot;</code>，或 <code>&quot;arts&quot;</code> 相似。</p>
<p>总之，它们通过相似性形成了两个关联组：<code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> 和 <code>{&quot;star&quot;}</code>。注意，<code>&quot;tars&quot;</code> 和 <code>&quot;arts&quot;</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p>
<p>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词。请问 <code>strs</code> 中有多少个相似字符串组？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p>这道题很明显的问有个相似字符串组，就几乎明示说要用并查集了，所以我们直接跟上面一题一样，只不过需要加上一个相似的逻辑判断即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] fathers = <span class="keyword">new</span> <span class="keyword">int</span>[strs.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.length;++i)&#123;</span><br><span class="line">            fathers[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;strs.length;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(similar(strs[i],strs[j]) &amp;&amp; union(fathers,i,j))&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFather</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fathers[i]!=i)&#123;</span><br><span class="line">            fathers[i] = getFather(fathers,fathers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fathers[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fatherOfI = getFather(fathers,i);</span><br><span class="line">        <span class="keyword">int</span> fatherOfJ = getFather(fathers,j);</span><br><span class="line">        <span class="keyword">if</span>(fatherOfI!=fatherOfJ)&#123;</span><br><span class="line">            fathers[fatherOfI] = fatherOfJ;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">similar</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diffCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str1.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1.charAt(i)!=str2.charAt(i))&#123;</span><br><span class="line">                diffCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diffCount&lt;=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="多余的边">多余的边</h4>
<blockquote>
<p>LeetCode 684</p>
<p>树可以看成是一个连通且 <strong>无环</strong> 的 <strong>无向</strong> 图。</p>
<p>给定往一棵 <code>n</code> 个节点 (节点值 <code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code> 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code> ，<code>edges[i] = [ai, bi]</code> 表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>
<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组 <code>edges</code> 中最后出现的边。</p>
</blockquote>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230304131923.png" style="zoom:80%;" />
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: edges &#x3D; [[1,2], [2,3], [3,4], [1,4], [1,5]]</span><br><span class="line">输出: [1,4]</span><br></pre></td></tr></table></figure>
<p>这道题还是并查集的套路题，其实也就是遍历每个<code>edge</code>，对两个顶点进行检查，看是不是属于同一子集，如果是同一子集说明加入就会形成环，返回这两个顶点即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] fathers = <span class="keyword">new</span> <span class="keyword">int</span>[edges.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fathers.length;++i)&#123;</span><br><span class="line">            fathers[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = edge[<span class="number">0</span>]-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> j = edge[<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!union(fathers,i,j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFathers</span><span class="params">(<span class="keyword">int</span>[] fathers,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fathers[i]!=i)&#123;</span><br><span class="line">            fathers[i]=getFathers(fathers,fathers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fathers[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fatherOfI = getFathers(fathers,i);</span><br><span class="line">        <span class="keyword">int</span> fatherOfJ = getFathers(fathers,j);</span><br><span class="line">        <span class="keyword">if</span>(fatherOfI!=fatherOfJ)&#123;</span><br><span class="line">            fathers[fatherOfI] = fatherOfJ;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长连续序列">最长连续序列</h4>
<blockquote>
<p>LeetCode 128</p>
<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>
<p>这道题其实就是将数子转换为有关系的图，每个数和比他大1或者小1的数之间存在边，那么我们就是要找最大自己的长度</p>
<p>所以我们还是可以用并查集来解决，并且用一个散列表记录根结点对应子集的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer,Integer&gt; fathers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer,Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        fathers.put(num,num);</span><br><span class="line">        counts.put(num,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fathers.containsKey(num+<span class="number">1</span>))&#123;</span><br><span class="line">            union(fathers,counts,num,num+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fathers.containsKey(num-<span class="number">1</span>))&#123;</span><br><span class="line">            union(fathers,counts,num,num-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> count:counts.values())&#123;</span><br><span class="line">        longest = Math.max(count,longest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFather</span><span class="params">(Map&lt;Integer,Integer&gt; fathers,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fathers.get(num)!=num)&#123;</span><br><span class="line">        fathers.put(num,getFather(fathers,fathers.get(num)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fathers.get(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Map&lt;Integer,Integer&gt; fathers,Map&lt;Integer,Integer&gt; count,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fatherOfI = getFather(fathers,i);</span><br><span class="line">    <span class="keyword">int</span> fatherOfJ = getFather(fathers,j);</span><br><span class="line">    <span class="keyword">if</span>(fatherOfI!=fatherOfJ)&#123;</span><br><span class="line">        fathers.put(fatherOfI,fatherOfJ);</span><br><span class="line">        <span class="keyword">int</span> countOfI = count.get(fatherOfI);</span><br><span class="line">        <span class="keyword">int</span> countOfJ = count.get(fatherOfJ);</span><br><span class="line">        count.put(fatherOfJ,countOfI+countOfJ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/28/%E5%A0%86/" rel="prev" title="堆">
      <i class="fa fa-chevron-left"></i> 堆
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/05/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="next" title="字符串">
      字符串 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">1.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#图的基本知识"><span class="nav-number">1.1.</span> <span class="nav-text">图的基本知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图的常见类型"><span class="nav-number">1.1.1.</span> <span class="nav-text">图的常见类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有向图和无向图"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">有向图和无向图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连通图和非连通图"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">连通图和非连通图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有权图和无权图"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">有权图和无权图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的表示"><span class="nav-number">1.1.2.</span> <span class="nav-text">图的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#邻接表"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">邻接表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#邻接矩阵"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">邻接矩阵</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的搜索"><span class="nav-number">1.2.</span> <span class="nav-text">图的搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#广度优先搜索"><span class="nav-number">1.2.1.</span> <span class="nav-text">广度优先搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深度优先遍历"><span class="nav-number">1.2.2.</span> <span class="nav-text">深度优先遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra算法"><span class="nav-number">1.2.3.</span> <span class="nav-text">Dijkstra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的搜索的应用"><span class="nav-number">1.2.4.</span> <span class="nav-text">图的搜索的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最大的岛屿"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">最大的岛屿</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二分图"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">二分图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#矩阵中的距离"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">矩阵中的距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单词演变"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">单词演变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开密码锁"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">开密码锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#所有路径"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">所有路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算除法"><span class="nav-number">1.2.4.7.</span> <span class="nav-text">计算除法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最长递增路径"><span class="nav-number">1.2.4.8.</span> <span class="nav-text">最长递增路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小生成树问题"><span class="nav-number">1.3.</span> <span class="nav-text">最小生成树问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Prim算法"><span class="nav-number">1.3.1.</span> <span class="nav-text">Prim算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kruskal算法"><span class="nav-number">1.3.2.</span> <span class="nav-text">Kruskal算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓扑排序"><span class="nav-number">1.4.</span> <span class="nav-text">拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#拓扑排序的基础知识"><span class="nav-number">1.4.1.</span> <span class="nav-text">拓扑排序的基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓扑排序的应用"><span class="nav-number">1.4.2.</span> <span class="nav-text">拓扑排序的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#课程顺序"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">课程顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外星文字典"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">外星文字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重建序列"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">重建序列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并查集"><span class="nav-number">1.5.</span> <span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并查集的基本知识"><span class="nav-number">1.5.1.</span> <span class="nav-text">并查集的基本知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并查集的应用"><span class="nav-number">1.5.2.</span> <span class="nav-text">并查集的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#朋友圈问题-省份数量"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">朋友圈问题&#x2F;省份数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相似的字符串"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">相似的字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多余的边"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">多余的边</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最长连续序列"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">最长连续序列</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wanghui Cai"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Wanghui Cai</p>
  <div class="site-description" itemprop="description">一些零零散散的学习总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bigmoom" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bigmoom" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:15850180970@163.com" title="E-Mail → mailto:15850180970@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="https://beian.miit.gov.cn/#/Integrated/index" rel="noopener" target="_blank">苏ICP备20010524 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wanghui Cai</span>
</div>




        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
