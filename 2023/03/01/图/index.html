<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="google-site-verification" content="_i0mgfxBy6QPgJZLx5NbYfLAp5i5xqHoSKIcpYOPHM0" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_i0mgfxBy6QPgJZLx5NbYfLAp5i5xqHoSKIcpYOPHM0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.caiwanghui.top","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="图  图的基本知识  相关图片来自Hello算法  图是一种非常重要且常见的数据结构，通常用来表示物与物之间的关系，如果两个物之间存在某种关系，则在图中对应的结点存在边相连。 图由顶点（Vertex）和边（Edge）构成，所以我们可以将图G表示成一组顶点V和一组边E的集合    图的常见类型  有向图和无向图 图可以分为有向图和无向图，如果给图中每条边规定一个方向，那么这样的图就是有向图，它的边">
<meta property="og:type" content="article">
<meta property="og:title" content="图">
<meta property="og:url" content="http://www.caiwanghui.top/2023/03/01/%E5%9B%BE/index.html">
<meta property="og:site_name" content="菜鸡肥肥的私人博客">
<meta property="og:description" content="图  图的基本知识  相关图片来自Hello算法  图是一种非常重要且常见的数据结构，通常用来表示物与物之间的关系，如果两个物之间存在某种关系，则在图中对应的结点存在边相连。 图由顶点（Vertex）和边（Edge）构成，所以我们可以将图G表示成一组顶点V和一组边E的集合    图的常见类型  有向图和无向图 图可以分为有向图和无向图，如果给图中每条边规定一个方向，那么这样的图就是有向图，它的边">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123254.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123316.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123946.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301124138.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301124447.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301130700.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301131127.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301142120.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301163332.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301163800.png">
<meta property="article:published_time" content="2023-03-01T11:08:01.000Z">
<meta property="article:modified_time" content="2023-03-01T12:24:56.508Z">
<meta property="article:author" content="Wanghui Cai">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123254.png">

<link rel="canonical" href="http://www.caiwanghui.top/2023/03/01/%E5%9B%BE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>图 | 菜鸡肥肥的私人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">菜鸡肥肥的私人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/03/01/%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          图
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-01 11:08:01 / 修改时间：12:24:56" itemprop="dateCreated datePublished" datetime="2023-03-01T11:08:01Z">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="图"><a class="markdownIt-Anchor" href="#图"></a> 图</h1>
<h2 id="图的基本知识"><a class="markdownIt-Anchor" href="#图的基本知识"></a> 图的基本知识</h2>
<blockquote>
<p>相关图片来自<a href="https://www.hello-algo.com/chapter_graph/graph/#911" target="_blank" rel="noopener">Hello算法</a></p>
</blockquote>
<p>图是一种非常重要且常见的数据结构，通常用来表示物与物之间的关系，如果两个物之间存在某种关系，则在图中对应的结点存在边相连。</p>
<p>图由顶点（Vertex）和边（Edge）构成，所以我们可以将图<code>G</code>表示成一组顶点<code>V</code>和一组边<code>E</code>的集合</p>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123254.png" style="zoom: 80%;" />
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123316.png" alt="" /></p>
<h3 id="图的常见类型"><a class="markdownIt-Anchor" href="#图的常见类型"></a> 图的常见类型</h3>
<h4 id="有向图和无向图"><a class="markdownIt-Anchor" href="#有向图和无向图"></a> 有向图和无向图</h4>
<p>图可以分为有向图和无向图，如果给图中每条边规定一个方向，那么这样的图就是有向图，它的边为有向边，如果否则为无向图</p>
<ul>
<li>有向图：只有单向的关系，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\rarr B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>←</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">B\larr A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>两个方向的边是相互独立的</li>
<li>无向图：无向图的边没有方向，表示双向的关系，可以看做有两条边</li>
</ul>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123946.png" style="zoom:80%;" />
<h4 id="连通图和非连通图"><a class="markdownIt-Anchor" href="#连通图和非连通图"></a> 连通图和非连通图</h4>
<ul>
<li>连通图：从某个顶点出发，可以到达任意剩余顶点</li>
<li>非连通图：从某个顶点出发，至少有有一个顶点无法到达</li>
</ul>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301124138.png" style="zoom:80%;" />
<h4 id="有权图和无权图"><a class="markdownIt-Anchor" href="#有权图和无权图"></a> 有权图和无权图</h4>
<ul>
<li>有权图：边存在权重，表示一种关系程度</li>
<li>无权图：与有权图相反，不存在权重，所有边等价</li>
</ul>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301124447.png" style="zoom:80%;" />
<h3 id="图的表示"><a class="markdownIt-Anchor" href="#图的表示"></a> 图的表示</h3>
<p>图的常见表示方法有两种，分别为<strong>邻接矩阵</strong>和<strong>邻接表</strong></p>
<h4 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h4>
<p>邻接表为图中的每个顶点创建一个容器，第<code>i</code>个容器保存所有与第<code>i</code>个顶点相邻的顶点</p>
<p>可以发现，邻接表和散列表非常类似，所以我们也可以与优化散列表一样，当链表过长是改成红黑树</p>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301130700.png" style="zoom:80%;" />
<h4 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h4>
<p>如果一个图中有<code>n</code>个结点，那么我们使用一个大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的邻接矩阵保存每条边的信息</p>
<p>如果顶点<code>i</code>和顶点<code>j</code>之间有一条边，那么<code>M[i][j]</code>等于1；反之如果没有边，则为0</p>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301131127.png" style="zoom:80%;" />
<p>当然，上面的邻接矩阵表示的是无向图，所以是一个对称矩阵且存在边用1表示，我们也可以用邻接矩阵表示有向图，<code>M[i][j]</code>表示顶点<code>i</code>和顶点<code>j</code>之间的权重</p>
<p>邻接矩阵的查找时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，但是空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，所以当一个图中顶点数目非常大且比较稀疏的时候邻接矩阵的空间效率就较低，应当选择邻接表。</p>
<h2 id="图的搜索"><a class="markdownIt-Anchor" href="#图的搜索"></a> 图的搜索</h2>
<p>和树的搜索一样，图的搜索也分为<strong>广度优先搜索（BFS）<strong>和</strong>深度优先搜索（DFS）</strong></p>
<h3 id="广度优先搜索"><a class="markdownIt-Anchor" href="#广度优先搜索"></a> 广度优先搜索</h3>
<p>广度优先遍历的思路和树的广度优先遍历思路差不多，只不过需要一个散列表或者其他容器记录该顶点是否有被访问过</p>
<ol>
<li>
<p>初始化队列和记录是否访问的散列表</p>
</li>
<li>
<p>开始顶点入队</p>
</li>
<li>
<p>出队，输出该结点</p>
</li>
<li>
<p>遍历出队顶点邻接结点，检查是否访问过</p>
</li>
<li>
<p>没有访问过则入队，否则无需操作</p>
</li>
<li>
<p>重复步骤3-5，直到队列为空</p>
</li>
</ol>
<p>由于每个顶点都会出队入队，使用时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>，遍历邻接顶点时，由于是无向图所以会被访问两遍，所有边都会被访问两遍，使用时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，总体时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maze[N][N] = &#123;</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">//使用邻接矩阵进行广度遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">graphBFS</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> startVertex)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(startVertex);</span><br><span class="line">    	visited.add(startVertex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> vertex = queue.poll();</span><br><span class="line">            result.add(vertex);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[vertex].length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[vertex][i]==<span class="number">1</span> &amp;&amp; !visited.contains(i))&#123;</span><br><span class="line">                    visited.add(i);</span><br><span class="line">                    queue.offer(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="深度优先遍历"><a class="markdownIt-Anchor" href="#深度优先遍历"></a> 深度优先遍历</h3>
<p>图的深度优先遍历也和树的深度优先遍历差不多，也是多了检查是否访问过这一步</p>
<blockquote>
<p>我们这里还是直接使用递归的方式实现深度优先遍历，有关迭代方法后面再补充</p>
</blockquote>
<ol>
<li>初始化记录是否访问状态的散列表</li>
<li>输出(开始)顶点，标记(开始)顶点已被访问</li>
<li>遍历顶点所有邻接顶点，对每个顶点转第2步操作（递归）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* int maze[N][N] = &#123;</span></span><br><span class="line"><span class="comment">	&#123; 0, 1, 1, 0, 0 &#125;,</span></span><br><span class="line"><span class="comment">	&#123; 0, 0, 1, 1, 0 &#125;,</span></span><br><span class="line"><span class="comment">	&#123; 0, 1, 1, 1, 0 &#125;,</span></span><br><span class="line"><span class="comment">	&#123; 1, 0, 0, 0, 0 &#125;,</span></span><br><span class="line"><span class="comment">	&#123; 0, 0, 1, 1, 0 &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphDFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result;</span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Integer&gt; visited;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">graphBFS</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> startVertex)</span></span>&#123;</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        visited = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(graph,startVertex);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> vertex)</span></span>&#123;</span><br><span class="line">        result.add(vertex);</span><br><span class="line">        visited.add(vertex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[vertex].length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited.contains(i) &amp;&amp; graph[vertex][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                dfs(graph,graph[vertex][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有顶点都被访问一遍，所有边都被访问两遍，所以时间复杂度还是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<h3 id="图的搜索的应用"><a class="markdownIt-Anchor" href="#图的搜索的应用"></a> 图的搜索的应用</h3>
<p>如果一个题目要求在<strong>无权图</strong>找出两个顶点的<strong>最短距离</strong>，建议使用<strong>广度优先遍历</strong>，如果要找出一条<strong>符合条件的路径</strong>，建议使用<strong>深度优先遍历</strong></p>
<h4 id="最大的岛屿"><a class="markdownIt-Anchor" href="#最大的岛屿"></a> 最大的岛屿</h4>
<blockquote>
<p>LeetCode 695</p>
<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>
<p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>
<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>
<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>
</blockquote>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301142120.png" style="zoom:67%;" />
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">输出：6</span><br><span class="line">解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。</span><br></pre></td></tr></table></figure>
<p>这道题最重要的就是要把题目转化为图的搜索，即每个岛屿就是一个子图，我们就是遍历子图，计算每个子图的顶点数</p>
<p>这里我们遍历整个<code>grid</code>，遇到没有访问过的岛屿，则计算这个岛屿的面积</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">    <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                maxArea = Math.max(maxArea, getArea(grid,visited,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于如何遍历子图顶点，广度遍历和深度遍历都可以</p>
<p>广度遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAreaBFS</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] operations = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span>[] position = queue.poll();</span><br><span class="line">        area++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] operation:operations)&#123;</span><br><span class="line">            <span class="keyword">int</span> adjR = position[<span class="number">0</span>]+operation[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> adjC = position[<span class="number">1</span>]+operation[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(adjR&gt;=<span class="number">0</span> &amp;&amp; adjR&lt;grid.length</span><br><span class="line">                &amp;&amp; adjC&gt;=<span class="number">0</span> &amp;&amp; adjC&lt;grid[<span class="number">0</span>].length</span><br><span class="line">                &amp;&amp; grid[adjR][adjC]==<span class="number">1</span> &amp;&amp; !visited[adjR][adjC])&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;adjR,adjC&#125;);</span><br><span class="line">                visited[adjR][adjC]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>深度遍历</p>
<p>这里我们使用栈实现深度遍历，其实就是将队列替换成了栈，因为栈具有先进后出的特点，所以直接可以实现深度遍历功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAreaDFS</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>[]&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> area=<span class="number">0</span>;</span><br><span class="line">    stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] operations = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span>[] location = stack.pop();</span><br><span class="line">        area++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] operation:operations)&#123;</span><br><span class="line">            <span class="keyword">int</span> adjR = location[<span class="number">0</span>]+operation[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> adjC = location[<span class="number">1</span>] + operation[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(adjR&gt;=<span class="number">0</span> &amp;&amp; adjR&lt;grid.length</span><br><span class="line">                &amp;&amp;adjC&gt;=<span class="number">0</span>&amp;&amp;adjC&lt;grid[<span class="number">0</span>].length</span><br><span class="line">                &amp;&amp;grid[adjR][adjC]==<span class="number">1</span> &amp;&amp; !visited[adjR][adjC])&#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;adjR,adjC&#125;);</span><br><span class="line">                visited[adjR][adjC]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分图"><a class="markdownIt-Anchor" href="#二分图"></a> 二分图</h4>
<blockquote>
<p>LeetCode 785</p>
<p>存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。给你一个二维数组 <code>graph</code> ，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于 <code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：</p>
<ul>
<li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li>
<li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li>
<li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li>
<li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li>
</ul>
<p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p>
<p>如果图是二分图，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
</blockquote>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301163332.png" style="zoom:67%;" />
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,2,3],[0,2],[0,1,3],[0,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。</span><br></pre></td></tr></table></figure>
<p>这一题乍一看跟遍历没什么关系，但我们可以将题目进行转化</p>
<p>我们对图中顶点进行遍历并上色，然后检查邻接顶点有没有上色，如果没有上色则上另一种颜色，如果有邻接顶点颜色与该顶点相同，则说明违法了二分图的规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = graph.length;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">int</span> color = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//initial color</span></span><br><span class="line">    Arrays.fill(colors,-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(colors[i]==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!setColorBFS(graph,i,colors,color))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setColorBFS</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> index,<span class="keyword">int</span>[] colors,<span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(index);</span><br><span class="line">    colors[index] = color;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> point = queue.poll();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> adj:graph[point])&#123;</span><br><span class="line">            <span class="keyword">if</span>(colors[adj]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(colors[adj]==colors[point])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                queue.offer(adj);</span><br><span class="line">                colors[adj] = <span class="number">1</span>-colors[point];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setColorDFS</span><span class="params">(<span class="keyword">int</span>[][] graph,<span class="keyword">int</span> index,<span class="keyword">int</span>[] colors,<span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(colors[index]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> colors[index]==color;</span><br><span class="line">    &#125;</span><br><span class="line">    colors[index] = color;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> adj:graph[index])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!setColorDFS(graph,adj,colors,<span class="number">1</span>-color))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="矩阵中的距离"><a class="markdownIt-Anchor" href="#矩阵中的距离"></a> 矩阵中的距离</h4>
<blockquote>
<p>LeetCode 542</p>
<p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>mat</code> ，请输出一个大小相同的矩阵，其中每一个格子是 <code>mat</code> 中对应位置元素到最近的 <code>0</code> 的距离。</p>
<p>两个相邻元素间的距离为 <code>1</code> 。</p>
</blockquote>
<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301163800.png" style="zoom:80%;" />
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat &#x3D; [[0,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">输出：[[0,0,0],[0,1,0],[1,2,1]]</span><br></pre></td></tr></table></figure>
<p>这道题直觉思路就是遍历每一个为1的元素，对其进行广度遍历，找到距离最短的0，但是这样的开销实在是太大了，不太现实</p>
<p>其实这道题是一到经典的<strong>多源广度遍历</strong>的问题，我们不再是以一个点为开始顶点，而是一群点作为第一行，然后第一行中的每一个找到下一行的元素，类似于树中遍历完这一层再遍历下一层</p>
<ul>
<li>这道题中我们就以值为0的顶点为第一层，把所有为0的顶点入队，并且距离设置为0</li>
<li>出队，检查上下左右邻接顶点是否被读过，如果没有读过，则距离+1并入队</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] mat) &#123;</span><br><span class="line">      Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[mat.length][mat[<span class="number">0</span>].length];</span><br><span class="line"><span class="comment">//不要用hashset，会超时        </span></span><br><span class="line">      <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[mat.length][mat[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mat.length;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;mat[i].length;j++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(mat[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                  dist[i][j]=<span class="number">0</span>;</span><br><span class="line">                  queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                  seen[i][j] = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span>[][] operations = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">int</span>[] position = queue.poll();</span><br><span class="line">          <span class="keyword">int</span> row = position[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">int</span> col = position[<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span>[] operation:operations)&#123;</span><br><span class="line">              <span class="keyword">int</span> newR = row+operation[<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">int</span> newC = col+operation[<span class="number">1</span>];</span><br><span class="line">              <span class="keyword">if</span>(newR&gt;=<span class="number">0</span>&amp;&amp;newC&gt;=<span class="number">0</span>&amp;&amp;newC&lt;mat[<span class="number">0</span>].length&amp;&amp;newR&lt;mat.length &amp;&amp;!seen[newR][newC])&#123;</span><br><span class="line">                  dist[newR][newC] = dist[row][col]+<span class="number">1</span>;</span><br><span class="line">                  queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newR,newC&#125;);</span><br><span class="line">                  seen[newR][newC]=<span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dist;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="单词演变"><a class="markdownIt-Anchor" href="#单词演变"></a> 单词演变</h4>
<blockquote>
<p>LeetCode 127</p>
<p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p>
<ul>
<li>每一对相邻的单词只差一个字母。</li>
<li>对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在 <code>wordList</code> 中。注意， <code>beginWord</code> 不需要在 <code>wordList</code> 中。</li>
<li><code>sk == endWord</code></li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 <code>0</code> 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure>
<p>这道题虽然说是一道<code>Hard</code>的题，但是转换之后就很简单</p>
<p>我们可以把<code>wordlist</code>里面的单词当做顶点，每个相邻的顶点构建一条边（题目中要求的字母相差一位），那么这道题其实就是无向图中求最短路径，所以我们可以直接使用广度优先遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    Queue&lt;String&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; notVisited = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line"></span><br><span class="line">    queue1.offer(beginWord);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        String word = queue1.poll();</span><br><span class="line">        <span class="keyword">if</span> (word.equals(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; adjWords = getAdjWords(word,notVisited);</span><br><span class="line">        <span class="keyword">for</span> (String adjWord : adjWords) &#123;</span><br><span class="line">            queue2.offer(adjWord);</span><br><span class="line">            notVisited.remove(adjWord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getAdjWords</span><span class="params">(String word,Set&lt;String&gt; notVisited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">    List&lt;String&gt; adjWords = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> char1 = chars[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'a'</span>;ch&lt;=<span class="string">'z'</span>;++ch)&#123;</span><br><span class="line">            <span class="keyword">if</span>(char1!=ch)&#123;</span><br><span class="line">                chars[i] = ch;</span><br><span class="line">                <span class="keyword">if</span>(notVisited.contains(String.valueOf(chars)))&#123;adjWords.add(String.valueOf(chars));&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chars[i] = char1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> adjWords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们使用了两个队列，也是类似于记录区别每一层的，这里是用来记录路径的长度</p>
<h2 id="最小路径问题"><a class="markdownIt-Anchor" href="#最小路径问题"></a> 最小路径问题</h2>
<h2 id="最小生成树问题"><a class="markdownIt-Anchor" href="#最小生成树问题"></a> 最小生成树问题</h2>
<h2 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h2>
<h2 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h2>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/28/%E5%A0%86/" rel="prev" title="堆">
      <i class="fa fa-chevron-left"></i> 堆
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#图"><span class="nav-number">1.</span> <span class="nav-text"> 图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#图的基本知识"><span class="nav-number">1.1.</span> <span class="nav-text"> 图的基本知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图的常见类型"><span class="nav-number">1.1.1.</span> <span class="nav-text"> 图的常见类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有向图和无向图"><span class="nav-number">1.1.1.1.</span> <span class="nav-text"> 有向图和无向图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连通图和非连通图"><span class="nav-number">1.1.1.2.</span> <span class="nav-text"> 连通图和非连通图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有权图和无权图"><span class="nav-number">1.1.1.3.</span> <span class="nav-text"> 有权图和无权图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的表示"><span class="nav-number">1.1.2.</span> <span class="nav-text"> 图的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#邻接表"><span class="nav-number">1.1.2.1.</span> <span class="nav-text"> 邻接表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#邻接矩阵"><span class="nav-number">1.1.2.2.</span> <span class="nav-text"> 邻接矩阵</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的搜索"><span class="nav-number">1.2.</span> <span class="nav-text"> 图的搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#广度优先搜索"><span class="nav-number">1.2.1.</span> <span class="nav-text"> 广度优先搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深度优先遍历"><span class="nav-number">1.2.2.</span> <span class="nav-text"> 深度优先遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的搜索的应用"><span class="nav-number">1.2.3.</span> <span class="nav-text"> 图的搜索的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最大的岛屿"><span class="nav-number">1.2.3.1.</span> <span class="nav-text"> 最大的岛屿</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二分图"><span class="nav-number">1.2.3.2.</span> <span class="nav-text"> 二分图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#矩阵中的距离"><span class="nav-number">1.2.3.3.</span> <span class="nav-text"> 矩阵中的距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单词演变"><span class="nav-number">1.2.3.4.</span> <span class="nav-text"> 单词演变</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小路径问题"><span class="nav-number">1.3.</span> <span class="nav-text"> 最小路径问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小生成树问题"><span class="nav-number">1.4.</span> <span class="nav-text"> 最小生成树问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓扑排序"><span class="nav-number">1.5.</span> <span class="nav-text"> 拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并查集"><span class="nav-number">1.6.</span> <span class="nav-text"> 并查集</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wanghui Cai"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Wanghui Cai</p>
  <div class="site-description" itemprop="description">一些零零散散的学习总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bigmoom" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bigmoom" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:15850180970@163.com" title="E-Mail → mailto:15850180970@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="https://beian.miit.gov.cn/#/Integrated/index" rel="noopener" target="_blank">苏ICP备20010524 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wanghui Cai</span>
</div>




        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
