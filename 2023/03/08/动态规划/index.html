<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="google-site-verification" content="_i0mgfxBy6QPgJZLx5NbYfLAp5i5xqHoSKIcpYOPHM0" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_i0mgfxBy6QPgJZLx5NbYfLAp5i5xqHoSKIcpYOPHM0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.caiwanghui.top","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="动态规划 动态规划介绍 动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 上面是来及wiki的介绍，其实动态规划说起来很简单，就是将复杂问题分解为子问题去解决 我们知道分治法也是将大问题化为子问题去解决，例如快速排序，将排序分为基准值左边和基准值右边">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划">
<meta property="og:url" content="http://www.caiwanghui.top/2023/03/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="菜鸡肥肥的私人博客">
<meta property="og:description" content="动态规划 动态规划介绍 动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 上面是来及wiki的介绍，其实动态规划说起来很简单，就是将复杂问题分解为子问题去解决 我们知道分治法也是将大问题化为子问题去解决，例如快速排序，将排序分为基准值左边和基准值右边">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230310133909.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230310170202.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230310171702.png">
<meta property="article:published_time" content="2023-03-08T13:40:06.000Z">
<meta property="article:modified_time" content="2023-03-24T14:03:27.339Z">
<meta property="article:author" content="Wanghui Cai">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230310133909.png">

<link rel="canonical" href="http://www.caiwanghui.top/2023/03/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>动态规划 | 菜鸡肥肥的私人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">菜鸡肥肥的私人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/03/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          动态规划
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-08 13:40:06" itemprop="dateCreated datePublished" datetime="2023-03-08T13:40:06Z">2023-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-24 14:03:27" itemprop="dateModified" datetime="2023-03-24T14:03:27Z">2023-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="动态规划">动态规划</h1>
<h2 id="动态规划介绍">动态规划介绍</h2>
<p><strong>动态规划</strong>（英语：Dynamic programming，简称DP）是一种在<a href="https://zh.wikipedia.org/wiki/数学" target="_blank" rel="noopener">数学</a>、<a href="https://zh.wikipedia.org/wiki/管理科学" target="_blank" rel="noopener">管理科学</a>、<a href="https://zh.wikipedia.org/wiki/计算机科学" target="_blank" rel="noopener">计算机科学</a>、<a href="https://zh.wikipedia.org/wiki/经济学" target="_blank" rel="noopener">经济学</a>和<a href="https://zh.wikipedia.org/wiki/生物信息学" target="_blank" rel="noopener">生物信息学</a>中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
<p>上面是来及wiki的介绍，其实动态规划说起来很简单，就是将复杂问题分解为子问题去解决</p>
<p>我们知道分治法也是将大问题化为子问题去解决，例如快速排序，将排序分为基准值左边和基准值右边继续排序，但是这种划分子问题的情况是子问题不存在重叠的情况，即左子问题与右子问题互不干扰，但是动态规划的子问题是存在相互重叠的情况</p>
<p>求解动态规划问题的步骤其实很简单，主要就以下几步：</p>
<ul>
<li>确定状态</li>
<li>拆分子问题，确定状态转移方程</li>
<li>优化复杂度</li>
</ul>
<a id="more"></a>
<p>我们直接以下面例子进行说明</p>
<blockquote>
<p>LeetCode 746</p>
<p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cost &#x3D; [10,15,20]</span><br><span class="line">输出：15</span><br><span class="line">解释：你将从下标为 1 的台阶开始。</span><br><span class="line">- 支付 15 ，向上爬两个台阶，到达楼梯顶部。</span><br><span class="line">总花费为 15 。</span><br></pre></td></tr></table></figure>
<p>这道题是动态规划中非常非常经典的一道题</p>
<ul>
<li><p>确定状态</p>
<p>通过分析，我们可以从<span class="math inline">\(i\)</span>级台阶网上爬花费为一个状态<span class="math inline">\(f(i)\)</span></p></li>
<li><p>拆分子问题，确定状态转移方程</p>
<p>题目告诉我们从一个台阶可以一次爬一级或者两级，那么我第<span class="math inline">\(i\)</span>级的台阶的最小开销就是爬一级到达该台阶以及爬两级到达该台阶的花费的最小值加上该台阶向上爬的花销，即 <span class="math display">\[
f(i) = min(f(i-1),f(i-2)) + cost[i]
\]</span> 当然这里<span class="math inline">\(i\geq2\)</span>，因为题目中说了可以从下标0或者1的台阶开始爬，所以<span class="math inline">\(f(0)=cost[0],f(1)=cost[1]\)</span></p></li>
</ul>
<p>我们先不看如何优化，有了状态转移方程，我们就可以直接通过递归求解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = cost.length;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp(cost,length-<span class="number">1</span>),dp(cost,length-<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] cost, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp(cost,i-<span class="number">1</span>),dp(cost,i-<span class="number">2</span>))+cost[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法非常简单，但是时间复杂度极其糟糕，因为我们需要重复计算很多次的相同子问题，例如我要求<span class="math inline">\(f(10)\)</span>，必然要求<span class="math inline">\(f(9),f(8)\)</span>，然后递归求解的时候<span class="math inline">\(f(6),f(7)\)</span>等等都重复计算了，所以时间复杂度很糟糕，接下来就是我们对动态规划经常要做的就是<strong>优化复杂度</strong></p>
<ul>
<li><p>使用缓存的递归方法</p>
<p>正如我们上面说的，我们存在很多被重复计算的代码，那么我们可以使用一个数组记录子问题的值，如果已经算过那就直接取值不需要再进行计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = cost.length;</span><br><span class="line">    <span class="keyword">int</span>[] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length];</span><br><span class="line">    dpStatus[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dpStatus[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">    dp(cost,length-<span class="number">1</span>,dpStatus);</span><br><span class="line">    <span class="keyword">return</span> Math.min(dpStatus[length-<span class="number">1</span>],dpStatus[length-<span class="number">2</span>]);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] cost, <span class="keyword">int</span> i,<span class="keyword">int</span>[] dpStatus)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dpStatus[i]==<span class="number">0</span> &amp;&amp; i&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        dp(cost,i-<span class="number">1</span>,dpStatus);</span><br><span class="line">        dp(cost,i-<span class="number">2</span>,dpStatus);</span><br><span class="line">        dpStatus[i] = Math.min(dpStatus[i-<span class="number">1</span>],dpStatus[i-<span class="number">2</span>])+cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自下而上的迭代方法</p>
<p>上面的方法都是由大问题化解为小问题，是一种自顶向下的方法，我们也可以自下而上的通过子问题求解大问题，例如我们先通过<span class="math inline">\(f(0),f(1)\)</span>求出<span class="math inline">\(f(2)\)</span>，然后通过<span class="math inline">\(f(1),f(2)\)</span>求出<span class="math inline">\(f(3)\)</span>，依次向上直到达到顶部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = cost.length;</span><br><span class="line">    <span class="keyword">int</span>[] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    dpStatus[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dpStatus[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;length;++i)&#123;</span><br><span class="line">        dpStatus[i] = Math.min(dpStatus[i-<span class="number">2</span>],dpStatus[i-<span class="number">1</span>])+cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Math.min(dpStatus[length-<span class="number">1</span>],dpStatus[length-<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>空间复杂度为<span class="math inline">\(O(1)\)</span>的迭代方法</p>
<p>上面的方法其实很优了，但是我们还是可以进行优化</p>
<p>我们发现我们其实并不需要存储每个状态，我们要的只不过是前面两个状态，所以我们只需要构建一个长度为2的数组存储前两个状态即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = cost.length;</span><br><span class="line">    <span class="keyword">int</span>[] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cost[<span class="number">0</span>],cost[<span class="number">1</span>]&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;length;++i)&#123;</span><br><span class="line">        dpStatus[i%<span class="number">2</span>] = Math.min(dpStatus[<span class="number">0</span>],dpStatus[<span class="number">1</span>])+cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Math.min(dpStatus[<span class="number">0</span>],dpStatus[<span class="number">1</span>]);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="动态规划常见题型">动态规划常见题型</h2>
<h3 id="单序列问题">单序列问题</h3>
<p>应用动态规划解决单序列问题的关键在于每一步在序列中增加一个元素，根据题目的特点找出元素对应的最优解和前面若干元素的最优解的关系即状态转移方程</p>
<h4 id="房屋偷盗">房屋偷盗</h4>
<blockquote>
<p>LeetCode 198</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>我们以<span class="math inline">\(f(i)\)</span>表示到房屋<span class="math inline">\(i\)</span>能偷取的最大金额</p></li>
<li><p>确定状态转移方程</p>
<p>我们观察在房屋<span class="math inline">\(i\)</span>的时候，我们有两种可能，偷与不偷，如果偷的话，那么我们就不可能偷<span class="math inline">\(i-1\)</span>房屋，这个时候<span class="math inline">\(f(i)=f(i-2)+nums[i]\)</span>，即到达房屋<span class="math inline">\(i-2\)</span>的最大金额加上偷<span class="math inline">\(i\)</span>的金额，那么如果不偷，就可以到达房屋<span class="math inline">\(i-1\)</span>，所以<span class="math inline">\(f(i) = f(i-1)\)</span>，所以转移方程就是 <span class="math display">\[
f(i) = max((f(i-2)+nums[i]),f(i-1))
\]</span> 这里的<span class="math inline">\(i\geq2\)</span>,当<span class="math inline">\(i=0\)</span>的时候，直接偷，<span class="math inline">\(i=1\)</span>的时候，<span class="math inline">\(f(1) = max(nums[0],nums[1])\)</span></p></li>
</ul>
<p>确定了转移方程之后就可以直接写了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[<span class="number">0</span>],Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;++i)&#123;</span><br><span class="line">        dpStatus[i%<span class="number">2</span>] = Math.max((dpStatus[(i-<span class="number">2</span>)%<span class="number">2</span>])+nums[i],dpStatus[(i-<span class="number">1</span>)%<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dpStatus[(len-<span class="number">1</span>)%<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上一题没差，都是可以只使用长度为2的数组存储前两个状态</p>
<p><strong>双状态转移方程</strong></p>
<p>这道题我们还可以通过两个状态转移方程来解决</p>
<p>我们将到达<span class="math inline">\(i\)</span>的状态分为偷与不偷，不偷的最大金额为<span class="math inline">\(f(i)\)</span>，偷的最大金额为<span class="math inline">\(g(i)\)</span>，那么<span class="math inline">\(i\)</span>状态能偷到的最大金额为<span class="math inline">\(max(f(i),g(i))\)</span>，接下来我们就要看关于<span class="math inline">\(f(i),g(i)\)</span>的状态转移方程</p>
<p>对于<span class="math inline">\(i\)</span>不偷，那么他不管进不进入<span class="math inline">\(i-1\)</span>，都不会触发报警，所以状态转移方程为： <span class="math display">\[
f(i) = max(f(i-1),g(i-1))
\]</span> 那么对于<span class="math inline">\(i\)</span>偷，对于<span class="math inline">\(i-1\)</span>只能不偷，所以状态转移方程为： <span class="math display">\[
g(i) = f(i-1)+nums[i]
\]</span> 那么有了状态转移方程，就可以直接开始写了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preF = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> preG = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempF = Math.max(preF,preG);</span><br><span class="line">        <span class="keyword">int</span> tempG = preF+nums[i];</span><br><span class="line">        preF = tempF;</span><br><span class="line">        preG = tempG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(preF,preG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="环形房屋偷盗">环形房屋偷盗</h4>
<blockquote>
<p>LeetCode 213</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<p>这道题和上面一题的区别就是这次的房屋形成了环，这个唯一的区别就是如果我偷了下标为0的房子，肯定不能偷最后的房子，如果没有偷下标为0的房子，那我就可以偷最后的房子</p>
<p>所以题目可以先转化为两个子问题，即偷下标<span class="math inline">\(0\to n-2\)</span>的房子和偷<span class="math inline">\(1\to n-1\)</span>的房子，然后对于每个子问题，就是上面的无环的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums.length==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(dp(nums,<span class="number">0</span>,length-<span class="number">2</span>),dp(nums,<span class="number">1</span>,length-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = start%<span class="number">2</span>==<span class="number">0</span>?<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[start],Math.max(nums[start],nums[start+<span class="number">1</span>])&#125;:<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Math.max(nums[start],nums[start+<span class="number">1</span>]),nums[start]&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">2</span>;i&lt;=end;++i)&#123;</span><br><span class="line">        dp[i%<span class="number">2</span>] = Math.max(dp[(i-<span class="number">1</span>)%<span class="number">2</span>],(dp[(i-<span class="number">2</span>)%<span class="number">2</span>]+nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[end%<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="粉刷房子">粉刷房子</h4>
<blockquote>
<p>LeetCode 256</p>
<p>假如有一排房子，共 <code>n</code> 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p>
<p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 <code>n x 3</code> 的正整数矩阵 <code>costs</code> 来表示的。</p>
<p>例如，<code>costs[0][0]</code> 表示第 0 号房子粉刷成红色的成本花费；<code>costs[1][2]</code> 表示第 1 号房子粉刷成绿色的花费，以此类推。</p>
<p>请计算出粉刷完所有房子最少的花费成本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: costs &#x3D; [[17,2,17],[16,16,5],[14,3,19]]</span><br><span class="line">输出: 10</span><br><span class="line">解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。</span><br><span class="line">     最少花费: 2 + 5 + 3 &#x3D; 10。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>对于每个房子我们可以涂三种颜色，所以可以设涂不同颜色的最小花费<span class="math inline">\(r(i),g(i),b(i)\)</span></p></li>
<li><p>确定状态转移方程</p>
<p>题目中限定了连续房子颜色不能相同，所以如果房子涂红色，那么前面房子只能涂蓝色或者绿色，我们取最小开销加上涂红色的开销就是当前房子涂红色的最小开销，同理其他颜色，所以我们就可以得到如下状态转移方程： <span class="math display">\[
r(i) = min(g(i-1),b(i-1))+cost[r][i]
\]</span></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = costs.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> preR = costs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> preB = costs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> preG = costs[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(preB,preG),preR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempR = Math.min(preG,preB)+costs[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> tempG = Math.min(preR,preB)+costs[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> tempB = Math.min(preR,preG)+costs[i][<span class="number">1</span>];</span><br><span class="line">        preR = tempR;</span><br><span class="line">        preG = tempG;</span><br><span class="line">        preB = tempB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(Math.min(preB,preG),preR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于只需要用到上一步的开销，所以不需要使用数组进行存储</p>
<h4 id="翻转字符">翻转字符</h4>
<blockquote>
<p>LeetCode 926</p>
<p>如果一个二进制字符串，是以一些 <code>0</code>（可能没有 <code>0</code>）后面跟着一些 <code>1</code>（也可能没有 <code>1</code>）的形式组成的，那么该字符串是 <strong>单调递增</strong> 的。</p>
<p>给你一个二进制字符串 <code>s</code>，你可以将任何 <code>0</code> 翻转为 <code>1</code> 或者将 <code>1</code> 翻转为 <code>0</code> 。</p>
<p>返回使 <code>s</code> 单调递增的最小翻转次数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;00110&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：翻转最后一位得到 00111.</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>我们可以发现字符串中字符要么是0要么是1，所以我们把问题拆分为最后一位是0的最小翻折次数<span class="math inline">\(f(i)\)</span>和最后一位是1的最小翻折次数<span class="math inline">\(g(i)\)</span>，两者取最小值即可以得到总的最小值</p></li>
<li><p>确定状态转移方程，对于字符<span class="math inline">\(i\)</span>，对于翻折有多种可能</p>
<ul>
<li><p><span class="math inline">\(i=0\)</span>，如果不翻转即还是为0，那么<span class="math inline">\(i-1\)</span>只能是0，所以 <span class="math display">\[
f(i)=f(i-1)
\]</span> 如果翻转为1 <span class="math display">\[
g(i)=min(f(i-1),g(i-1))+1
\]</span></p></li>
<li><p><span class="math inline">\(i=1\)</span>，如果翻转，即0，那么前一位也肯定是0 <span class="math display">\[
f(i) = f(i-1)+1
\]</span> 不翻转 <span class="math display">\[
g(i)=min(f(i-1),g(i-1))
\]</span></p></li>
</ul></li>
</ul>
<p>得到状态转移方程之后就很简单了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFlipsMonoIncr</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> preF;</span><br><span class="line">    <span class="keyword">int</span> preG;</span><br><span class="line">    <span class="keyword">if</span>(s.charAt(<span class="number">0</span>)==<span class="string">'0'</span>)&#123;</span><br><span class="line">        preF = <span class="number">0</span>;</span><br><span class="line">        preG = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        preF = <span class="number">1</span>;</span><br><span class="line">        preG = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempF;</span><br><span class="line">        <span class="keyword">int</span> tempG;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">'0'</span>)&#123;</span><br><span class="line">            tempF = preF;</span><br><span class="line">            tempG = Math.min(preF,preG)+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tempF = preF +<span class="number">1</span>;</span><br><span class="line">            tempG = Math.min(preF,preG);</span><br><span class="line">        &#125;</span><br><span class="line">        preF = tempF;</span><br><span class="line">        preG = tempG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(preF,preG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长斐波那契数列">最长斐波那契数列</h4>
<blockquote>
<p>LeetCode 873</p>
<p>如果序列 <code>X_1, X_2, ..., X_n</code> 满足下列条件，就说它是 <em>斐波那契式</em> 的：</p>
<ul>
<li><code>n &gt;= 3</code></li>
<li>对于所有 <code>i + 2 &lt;= n</code>，都有 <code>X_i + X_{i+1} = X_{i+2}</code></li>
</ul>
<p>给定一个<strong>严格递增</strong>的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。</p>
<p><em>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， <code>[3, 5, 8]</code> 是 <code>[3, 4, 5, 6, 7, 8]</code> 的一个子序列）</em></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: arr &#x3D; [1,2,3,4,5,6,7,8]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>这道题的状态有点难找，我们以上面的实例来看</p>
<p>我们要找以8结尾的斐波那契式，我们可以看到倒数第二个数为7的时候，存在1使得斐波那契式成立，倒数第二个数为6的时候，存在2，倒数第二个数为5的时候，有<code>[1,2,3,5]</code>前置斐波那契式。。。</p>
<p>所以我们可以发现，我们斐波那契数的后面两个数为状态，即<span class="math inline">\(f(i,j)\)</span>，表示以<span class="math inline">\(i\)</span>为最后一位，<span class="math inline">\(j\)</span>为倒数第二位的斐波那契式的最长长度</p></li>
<li><p>确定状态转移方程</p>
<p>我们可以发现，确定<span class="math inline">\(i,j\)</span>之后，我们寻找有没有一个数<span class="math inline">\(k\)</span>使得<span class="math inline">\(arr[k]+arr[j]=arr[j]\)</span>，如果存在就 <span class="math display">\[
f(i,j) = f(j,k)+1
\]</span></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        indexMap.put(arr[i],i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = indexMap.getOrDefault(arr[i]-arr[j],-<span class="number">1</span>);</span><br><span class="line">            dpStatus[i][j] = k&gt;=<span class="number">0</span> &amp;&amp; k&lt;j?dpStatus[j][k]+<span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            result = Math.max(result,dpStatus[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result&gt;<span class="number">2</span>?result:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最少回文分割">最少回文分割</h4>
<blockquote>
<p>LeetCode 132</p>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aab&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：只需一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>这道题状态其实很好确定，就是设到达字符<span class="math inline">\(i\)</span>的时候最少分割次数为<span class="math inline">\(f(i)\)</span></p></li>
<li><p>确定状态转移方程</p>
<p>我们以字符<span class="math inline">\(i\)</span>寻找如何确定他的最少分割次数，首先，从<span class="math inline">\(0\to i\)</span>构成的字符是回文字符串，那么<span class="math inline">\(f(i)=0\)</span>，如果不是，那么我们就往前找，找看哪个字符<span class="math inline">\(j\)</span>，<span class="math inline">\(j\to i\)</span>构成字符为回文字符串，这个时候只需要再切割一次就可以，但是这并不是唯一能构成回文字符串的字符，我们要遍历前面所有字符串，寻找到最小分割次数而且能形成回文字符串的字符，所以状态转移方程就是 <span class="math display">\[
f(i) = min(f(j))+1
\]</span></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] isPal = <span class="keyword">new</span> <span class="keyword">boolean</span>[length][length];</span><br><span class="line">    <span class="keyword">int</span>[] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> ch2 = s.charAt(j);</span><br><span class="line">            <span class="keyword">if</span>(ch1==ch2 &amp;&amp; (i&lt;=j+<span class="number">1</span> || isPal[j+<span class="number">1</span>][i-<span class="number">1</span>]))&#123;</span><br><span class="line">                isPal[j][i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPal[<span class="number">0</span>][i])&#123;</span><br><span class="line">            dpStatus[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dpStatus[i] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isPal[j][i])&#123;</span><br><span class="line">                    dpStatus[i] = Math.min(dpStatus[i],dpStatus[j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dpStatus[length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码对判断回文字符串进行了优化，不用每次使用双指针进行遍历，判断的条件可以转换为</p>
<p>判断<span class="math inline">\(S[j\to i]\)</span>是不是回文字符串，只需要判断<span class="math inline">\(S[j]=S[i]\)</span>并且<span class="math inline">\(S[j+1\to i-1]\)</span>是回文字符串即可</p>
<h3 id="双序列问题">双序列问题</h3>
<h4 id="最长公共子序列">最长公共子序列</h4>
<blockquote>
<p>LeetCode 1143</p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但 <code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>我们可以直接用<span class="math inline">\(f(i,j)\)</span>表明第一个字符串<span class="math inline">\(0\to i\)</span>和第二个字符串<span class="math inline">\(0\to j\)</span>这两个子串的最长公共子序列</p></li>
<li><p>确定状态转移方程</p>
<p>观察发现，当<span class="math inline">\(i,j\)</span>两个字符相等的时候，最长子序列为<span class="math inline">\(f(i-1,j-1)\)</span>加1</p>
<p>而当两个字符不相等的时候，说明不能同时在子序列中加上末尾的元素，俺么最长子序列即为<span class="math inline">\(f(i-1,j)\)</span>和<span class="math inline">\(f(i,j-1)\)</span>中的最大值</p>
<p>所以状态转移方程为： $$ f(i,j)=</p>
<span class="math display">\[\begin{cases}
f(i-1,j-1)+1,s1[i]==s2[j]\\
max(f(i-1,j),f(i,j-1)),s1[i]\not=s2[j]

\end{cases}\]</span>
<p>$$</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len1&lt;len2)&#123;</span><br><span class="line">        <span class="keyword">return</span> longestCommonSubsequence(text2,text1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][len2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len2;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1.charAt(i)==text2.charAt(j))&#123;</span><br><span class="line">                dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j+<span class="number">1</span>] = dpStatus[i%<span class="number">2</span>][j]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j+<span class="number">1</span>] = Math.max(dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j],dpStatus[i%<span class="number">2</span>][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpStatus[len1%<span class="number">2</span>][len2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码我们只使用了两行的二维数组存储状态，因为我们发现求<span class="math inline">\(f(i,j)\)</span>的时候只需要使用<span class="math inline">\(f(i-1,j-1),f(i-1,j),f(i,j-1)\)</span>周围三个，只需要两行即可</p>
<p>当然更优化的只需要一个一维数组即可，这边就不写了</p>
<h4 id="字符串交织">字符串交织</h4>
<blockquote>
<p>LeetCode 97</p>
<p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> <strong>交错</strong> 组成的。</p>
<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p>
<ul>
<li><code>s = s1 + s2 + ... + sn</code></li>
<li><code>t = t1 + t2 + ... + tm</code></li>
<li><code>|n - m| &lt;= 1</code></li>
<li><strong>交错</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li>
</ul>
<p><strong>注意：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>
</blockquote>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230310133909.png" style="zoom:80%;" /></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>因为是双序列问题，所以我们还是使用<span class="math inline">\(f(i,j)\)</span>表示状态，这边可以表示为字符串<code>s1</code>中从下标0到下标<code>i</code>和字符串<code>s2</code>从下标0到下标<code>j</code>能不能构成字符串<code>s3</code>中下标0到下标<code>i+j+1</code></p></li>
<li><p>确定状态转移方程</p>
<p>我们可以发现如果<span class="math inline">\(s1[i]=s3[i+j+1]\)</span>，那么<span class="math inline">\(f(i,j)=f(i-1,j)\)</span>，即只要前面可以，那我这个肯定可以，同理当<span class="math inline">\(s2[j]=s3[i+j+1]\)</span>，<span class="math inline">\(f(i,j)=f(i,j-1)\)</span>，如果<span class="math inline">\(s1[i]=s2[j]=s3[i+j+i]\)</span>，那么只需要<span class="math inline">\(f(i,j-1),f(i-1,j)\)</span>有一个为<code>true</code>，<span class="math inline">\(f(i,j)\)</span>就为<code>true</code></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s1.length()+s2.length()!=s3.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s1.length()&lt;s2.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> isInterleave(s2,s1,s3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s1.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[][] dpStatus = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>][s2.length()+<span class="number">1</span>];</span><br><span class="line">    dpStatus[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    dpStatus[<span class="number">1</span>][<span class="number">0</span>] = s1.charAt(<span class="number">0</span>)==s3.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s2.length();++i)&#123;</span><br><span class="line">        dpStatus[<span class="number">0</span>][i+<span class="number">1</span>] = s2.charAt(i)==s3.charAt(i) &amp;&amp; dpStatus[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length();++i)&#123;</span><br><span class="line">        dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>] = dpStatus[i%<span class="number">2</span>][<span class="number">0</span>] &amp;&amp; s1.charAt(i)==s3.charAt(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s2.length();++j)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = s1.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> ch2 = s2.charAt(j);</span><br><span class="line">            <span class="keyword">char</span> ch3 = s3.charAt(i+j+<span class="number">1</span>);</span><br><span class="line">            dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j+<span class="number">1</span>] = (ch1==ch3 &amp;&amp; dpStatus[i%<span class="number">2</span>][j+<span class="number">1</span>]) ||</span><br><span class="line">                    (ch2==ch3 &amp;&amp; dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dpStatus[s1.length()%<span class="number">2</span>][s2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题还是只需使用<span class="math inline">\(f(i-1,j)和\)</span><span class="math inline">\(f(i,j-1)\)</span>，所以只需要使用两行来存储即可</p>
<h4 id="子序列的数目">子序列的数目</h4>
<blockquote>
<p>LeetCode 115</p>
<p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p>
<p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>"ACE"</code> 是 <code>"ABCDE"</code> 的一个子序列，而 <code>"AEC"</code> 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;rabbbit&quot;, t &#x3D; &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>还是说经典双序列问题，我们依旧使用<span class="math inline">\(f(i,j)\)</span>表示状态，这里表示字符串中<code>s</code>中下标由0到<code>i</code>的字符串中包含字符串<code>t</code>中下标由0到<code>j</code>的字符串的子序列个数</p></li>
<li><p>确定状态转移方程</p>
<p>观察发现，当<span class="math inline">\(s[i]=t[j]\)</span>的时候，<span class="math inline">\(f(i,j)\)</span>肯定要包括没有<span class="math inline">\(s[i]\)</span>的时候能够成的子序列个数<span class="math inline">\(f(i-1,j)\)</span>，那么因为加上了该字符，因为与<span class="math inline">\(t[j]\)</span>相等，所以可以看作等于把这个字符都删除后的<code>s,t</code>的个数，即<span class="math inline">\(f(i-1,j-1)\)</span>，所以<span class="math inline">\(f(i,j)=f(i-1,j)+f(i-1,j-1)\)</span></p>
<p>如果不相等的情况下，就直接是等于<span class="math inline">\(f(i-1,j)\)</span></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> len1 = s.length();</span><br><span class="line">     <span class="keyword">int</span> len2 = t.length();</span><br><span class="line">     <span class="keyword">if</span> (len1 &lt; len2) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">int</span>[][] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][t.length() + <span class="number">1</span>];</span><br><span class="line">     dpStatus[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">     dpStatus[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">         dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;=i &amp;&amp; j &lt; t.length(); j++) &#123;</span><br><span class="line">             <span class="keyword">char</span> ch1 = s.charAt(i);</span><br><span class="line">             <span class="keyword">char</span> ch2 = t.charAt(j);</span><br><span class="line">             <span class="keyword">if</span> (ch1 == ch2) &#123;</span><br><span class="line">                 dpStatus[(i + <span class="number">1</span>) % <span class="number">2</span>][j + <span class="number">1</span>] = dpStatus[i % <span class="number">2</span>][j] + dpStatus[i % <span class="number">2</span>][j + <span class="number">1</span>];</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                 dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j+<span class="number">1</span>] = dpStatus[i%<span class="number">2</span>][j+<span class="number">1</span>];</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> dpStatus[s.length()%<span class="number">2</span>][t.length()];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵路径问题">矩阵路径问题</h3>
<h4 id="路径的数目">路径的数目</h4>
<blockquote>
<p>LeetCode 62</p>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
</blockquote>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230310170202.png" /></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>矩阵中路径的路径和双序列差不多，也是设<span class="math inline">\(f(i,j)\)</span>表示在坐标<span class="math inline">\((i,j)\)</span>处的状态，这里<span class="math inline">\(f(i,j)\)</span>表示到达<span class="math inline">\((i,j)\)</span>的路径数</p></li>
<li><p>确定状态转移方程</p>
<p>这道题的状态转移方程还是非常简单的，因为机器人只能向右向下行动，所以<span class="math inline">\(f(i,j)=f(i-1,j)+f(i,j-1)\)</span>，当<span class="math inline">\(i=1\)</span>或者<span class="math inline">\(j=1\)</span>的时候必然为1</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i%<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[i%<span class="number">2</span>][j] = dp[(i-<span class="number">1</span>)%<span class="number">2</span>][j] + dp[i%<span class="number">2</span>][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[(m-<span class="number">1</span>)%<span class="number">2</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小路径之和">最小路径之和</h4>
<blockquote>
<p>LeetCode 64</p>
<p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
</blockquote>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230310171702.png" style="zoom:67%;" /></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>
<p>这一题和上一题几乎一模一样，只有状态转移方程有点不同</p>
<p>这里的状态转移方程为上方和左方的状态的最小值加上矩阵的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = grid.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][len2];</span><br><span class="line">    dpStatus[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len2;i++)&#123;</span><br><span class="line">        dpStatus[<span class="number">0</span>][i] = dpStatus[<span class="number">0</span>][i-<span class="number">1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">        dpStatus[i%<span class="number">2</span>][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + dpStatus[(i-<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2;++j)&#123;</span><br><span class="line">            dpStatus[i%<span class="number">2</span>][j] = Math.min(dpStatus[(i-<span class="number">1</span>)%<span class="number">2</span>][j] , dpStatus[i%<span class="number">2</span>][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dpStatus[(len1-<span class="number">1</span>)%<span class="number">2</span>][len2-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三角形中最小路径之和">三角形中最小路径之和</h4>
<blockquote>
<p>LeetCode 120</p>
<p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：triangle &#x3D; [[2],[3,4],[6,5,7],[4,1,8,3]]</span><br><span class="line">输出：11</span><br><span class="line">解释：如下面简图所示：</span><br><span class="line">   2</span><br><span class="line">  3 4</span><br><span class="line"> 6 5 7</span><br><span class="line">4 1 8 3</span><br><span class="line">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</span><br></pre></td></tr></table></figure>
<p>这道题和上面两题几乎没有什么区别，只不过是限定为三角形，所以状态转移方程就是取左上或者正上方中较小值再加上本身的值即可</p>
<p>此外题目要求使用<span class="math inline">\(O(N)\)</span>的空间，所以我们可以构造一个等大的二维数组不过也可以是直接在输入的方程里面修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;triangle.size();i++)&#123;</span><br><span class="line">        triangle.get(i).set(<span class="number">0</span>,triangle.get(i-<span class="number">1</span>).get(<span class="number">0</span>)+triangle.get(i).get(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==i)&#123;</span><br><span class="line">                triangle.get(i).set(j,triangle.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>)+triangle.get(i).get(j));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                triangle.get(i).set(j,Math.min(triangle.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>),triangle.get(i-<span class="number">1</span>).get(j))+triangle.get(i).get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; bottom = triangle.get(triangle.size()-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(Integer total:bottom)&#123;</span><br><span class="line">        min = Math.min(min,total);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="背包问题">背包问题</h3>
<h4 id="分割等和子集">分割等和子集</h4>
<blockquote>
<p>LeetCode 416</p>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure>
<p>这道题其实可以转化为经典0-1背包问题</p>
<p>题目要求能不能分成两个元素和相同的元素，首先，我们可以求出来<code>nums</code>的总和<code>sum</code>，如果总和是奇数那必然是不可能的，然后总和为偶数，我们就可以将问题转化为<code>nums</code>里面能不能通过加减项使得和为<span class="math inline">\(\frac{sum}{2}\)</span></p>
<ul>
<li><p>确定状态</p>
<p>所以我们可以设定状态为<span class="math inline">\(f(n,t)\)</span>，表示<span class="math inline">\(n\)</span>个元素能不能满足子项的和为<span class="math inline">\(t\)</span></p></li>
<li><p>确定状态转移方程</p>
<p>与0-1背包问题类似，我们可以面对每个元素，可以选择是不是放进背包，这里就是选择是不是加起来</p>
<p>如果加起来，那么我们就得看<span class="math inline">\(f(n,t-nums[i])\)</span>，如果不选，那么<span class="math inline">\(f(n,t)=f(n-1,t)\)</span></p>
<p>这里我们需要注意<span class="math inline">\(t-nums[i]\)</span>，如果小于零说明必然不可能选这个，所以这个时候<span class="math inline">\(f(n,t)=f(n-1,t)\)</span></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        sum+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(nums,sum/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dpStatus = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>][target+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    dpStatus[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;target;++i)&#123;</span><br><span class="line">        dpStatus[<span class="number">0</span>][i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j] = dpStatus[i%<span class="number">2</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j] = dpStatus[i%<span class="number">2</span>][j-nums[i]] || dpStatus[i%<span class="number">2</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpStatus[length%<span class="number">2</span>][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加减的目标值">加减的目标值</h4>
<blockquote>
<p>LeetCode 494</p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>"+2-1"</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 &#x3D; 3</span><br></pre></td></tr></table></figure>
<p>这道题一眼回溯，每个数字有两个选择，但是回溯下来时间复杂度将会非常高，是<span class="math inline">\(O(2^N)\)</span></p>
<p>我们这里使用动态规划来处理</p>
<p>我们首先可以对问题进行一个巧妙的转化</p>
<p>我们设所有加号的项的和为<span class="math inline">\(p\)</span>，所有减号的项和为<span class="math inline">\(q\)</span>，可以得到下面的式子： <span class="math display">\[
p+q = sum \\
p-q = target\\
p = \frac{sum+target}{2}\\
q = \frac{sum-target}{2}
\]</span> 我们就可以将问题转化为求数组中有没有项的和为<span class="math inline">\(p\)</span>或者<span class="math inline">\(q\)</span>，即经典0-1背包问题</p>
<p>那么对于状态方程，我们使用<span class="math inline">\(f(i,j)\)</span>表示前<span class="math inline">\(i\)</span>项可以组成和为<span class="math inline">\(j\)</span>的方案个数 <span class="math display">\[
f(i,j) =
\begin{cases}
f(i-1,j),nums[i]&gt;j\\
f(i-1,j)+f(i-1,j-nums[i]),nums[i]\leq j
\end{cases}
\]</span> 这里状态转移方程的意思就是第<span class="math inline">\(i\)</span>项拿与不拿的两种选项，如果大于目标和那我肯定不拿，如果不大于目标和那我既可以拿也可以不拿</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> newTarget;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> == <span class="number">1</span> || target &gt; sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newTarget = (sum - target) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][newTarget+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dpStatus[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= newTarget; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                    dpStatus[i % <span class="number">2</span>][j] = dpStatus[(i + <span class="number">1</span>) % <span class="number">2</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dpStatus[i % <span class="number">2</span>][j] = dpStatus[(i + <span class="number">1</span>) % <span class="number">2</span>][j] + dpStatus[(i + <span class="number">1</span>) % <span class="number">2</span>][j - nums[i-<span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dpStatus[nums.length%<span class="number">2</span>][newTarget];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最少的硬币数目">最少的硬币数目</h4>
<blockquote>
<p>LeetCode 322</p>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>
<p>这道题就是非常经典的无穷背包问题，即每一个东西我都可以不止拿一个</p>
<p>我们先设定状态为<span class="math inline">\(f(i,j)\)</span>，表示我用前<span class="math inline">\(i\)</span>个硬币组成金额为<span class="math inline">\(j\)</span>的最少硬币个数</p>
<p>那么对于每个硬币，我可以有多种选择，可以不选，可以选一个，选两个等等</p>
<p>所以我<span class="math inline">\(f(i,j)\)</span>应该是这些所有状态的最小值，即： <span class="math display">\[
f(i,j) = \min  (f(i-1,j-k*num[i-1])+k)
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][amount+<span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dpStatus[<span class="number">0</span>],amount+<span class="number">1</span>);</span><br><span class="line">    dpStatus[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coins.length;++i)&#123;</span><br><span class="line">        dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">            dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j] = dpStatus[i%<span class="number">2</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k*coins[i]&lt;=j;k++)&#123;</span><br><span class="line">                dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j] = Math.min(dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j],dpStatus[i%<span class="number">2</span>][j-k*coins[i]]+k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dpStatus[coins.length%<span class="number">2</span>][amount]&gt;amount?-<span class="number">1</span>:dpStatus[coins.length%<span class="number">2</span>][amount];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="排列的数目">排列的数目</h4>
<blockquote>
<p>LeetCode 377</p>
<p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3], target &#x3D; 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure>
<p>这道题和上一题其实差不多，不一样的就是上一题是要求最小的个数，而这一题是要求全排列的个数，所以就是状态转移方程不一样</p>
<p>我们这里可以直接用<span class="math inline">\(f(i)\)</span>，表示和为<span class="math inline">\(i\)</span>的排列组合个数</p>
<p>我们这里是要求和为<span class="math inline">\(i\)</span>的所有排列组合，我们可以看组合中最后的这个数<span class="math inline">\(num\)</span>，很明显在最后加上<span class="math inline">\(num\)</span>的排列组合数就是<span class="math inline">\(f(i-num)\)</span>，那么我们只需要遍历所有<span class="math inline">\(num\)</span>，把这些求和即可得到以<span class="math inline">\(num\)</span>结尾的且和为<span class="math inline">\(i\)</span>排列组合的个数 <span class="math display">\[
f(i,j) = \sum f(i-nums[j]),nums[j]\leq i
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">    dpStatus[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= i) &#123;</span><br><span class="line">                dpStatus[i] += dpStatus[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dpStatus[target];</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/05/%E6%8E%92%E5%BA%8F/" rel="prev" title="排序">
      <i class="fa fa-chevron-left"></i> 排序
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/08/%E5%9B%9E%E6%BA%AF%E6%B3%95/" rel="next" title="回溯法">
      回溯法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#动态规划"><span class="nav-number">1.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划介绍"><span class="nav-number">1.1.</span> <span class="nav-text">动态规划介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划常见题型"><span class="nav-number">1.2.</span> <span class="nav-text">动态规划常见题型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单序列问题"><span class="nav-number">1.2.1.</span> <span class="nav-text">单序列问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#房屋偷盗"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">房屋偷盗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#环形房屋偷盗"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">环形房屋偷盗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#粉刷房子"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">粉刷房子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#翻转字符"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">翻转字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最长斐波那契数列"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">最长斐波那契数列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最少回文分割"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">最少回文分割</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双序列问题"><span class="nav-number">1.2.2.</span> <span class="nav-text">双序列问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最长公共子序列"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串交织"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">字符串交织</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子序列的数目"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">子序列的数目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵路径问题"><span class="nav-number">1.2.3.</span> <span class="nav-text">矩阵路径问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#路径的数目"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">路径的数目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最小路径之和"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">最小路径之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三角形中最小路径之和"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">三角形中最小路径之和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#背包问题"><span class="nav-number">1.2.4.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分割等和子集"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">分割等和子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加减的目标值"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">加减的目标值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最少的硬币数目"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">最少的硬币数目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排列的数目"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">排列的数目</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wanghui Cai"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Wanghui Cai</p>
  <div class="site-description" itemprop="description">一些零零散散的学习总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bigmoom" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bigmoom" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:15850180970@163.com" title="E-Mail → mailto:15850180970@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="https://beian.miit.gov.cn/#/Integrated/index" rel="noopener" target="_blank">苏ICP备20010524 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wanghui Cai</span>
</div>




        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
