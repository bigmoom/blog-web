<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="google-site-verification" content="_i0mgfxBy6QPgJZLx5NbYfLAp5i5xqHoSKIcpYOPHM0" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_i0mgfxBy6QPgJZLx5NbYfLAp5i5xqHoSKIcpYOPHM0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.caiwanghui.top","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回溯法 回溯法的基础知识 回溯法可以看做是蛮力法的升级，它在解决问题的每一步都尝试祝所有可能的选项，最终找出所有可行的解决方案 所以回溯法特别适用于解决由多个步骤组成的问题，并且每个步骤都有多个选项。在某一步选择了其中一个选项之后进入到下一步并面临新的选项，直到到达最终的状态  例如我们这里想要获得根结点到叶子结点的所有路径，其实就类似于树的深度遍历 以上图为例，从根结点开始，只有结点">
<meta property="og:type" content="article">
<meta property="og:title" content="回溯法">
<meta property="og:url" content="http://www.caiwanghui.top/2023/03/08/%E5%9B%9E%E6%BA%AF%E6%B3%95/index.html">
<meta property="og:site_name" content="菜鸡肥肥的私人博客">
<meta property="og:description" content="回溯法 回溯法的基础知识 回溯法可以看做是蛮力法的升级，它在解决问题的每一步都尝试祝所有可能的选项，最终找出所有可行的解决方案 所以回溯法特别适用于解决由多个步骤组成的问题，并且每个步骤都有多个选项。在某一步选择了其中一个选项之后进入到下一步并面临新的选项，直到到达最终的状态  例如我们这里想要获得根结点到叶子结点的所有路径，其实就类似于树的深度遍历 以上图为例，从根结点开始，只有结点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230308143936.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230308190346.png">
<meta property="og:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230308190632.png">
<meta property="article:published_time" content="2023-03-08T13:41:32.000Z">
<meta property="article:modified_time" content="2023-03-08T12:55:34.063Z">
<meta property="article:author" content="Wanghui Cai">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230308143936.png">

<link rel="canonical" href="http://www.caiwanghui.top/2023/03/08/%E5%9B%9E%E6%BA%AF%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>回溯法 | 菜鸡肥肥的私人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">菜鸡肥肥的私人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/03/08/%E5%9B%9E%E6%BA%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          回溯法
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-08 13:41:32 / 修改时间：12:55:34" itemprop="dateCreated datePublished" datetime="2023-03-08T13:41:32Z">2023-03-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="回溯法">回溯法</h1>
<h2 id="回溯法的基础知识">回溯法的基础知识</h2>
<p>回溯法可以看做是蛮力法的升级，它在解决问题的每一步都尝试祝所有可能的选项，最终找出所有可行的解决方案</p>
<p>所以回溯法特别适用于解决由多个步骤组成的问题，并且每个步骤都有多个选项。在某一步选择了其中一个选项之后进入到下一步并面临新的选项，直到到达最终的状态</p>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230308143936.png" style="zoom:67%;" /></p>
<p>例如我们这里想要获得根结点到叶子结点的所有路径，其实就类似于树的深度遍历</p>
<p>以上图为例，从根结点开始，只有结点2这个选项，所以选择2</p>
<p>到达结点2，现在有3个选项，我们先选择结点3，发现为叶子结点，即到达最终状态，输出<code>123</code></p>
<p>向上回溯，这里回溯与树的<code>dfs</code>不同的是，这里的回溯指的是回归到结点2的状态，即当作没有访问过结点3，继续访问结点4，那么照样输出<code>124</code>，如果这里不忘记结点3，那么正常的<code>DFS</code>的前序遍历，可能就会输出<code>1234</code>，这不是我们想要的</p>
<p>继续回溯，选择新的选项，到达结点5，输出<code>125</code></p>
<p>由于回溯法实在所有选项形成的解空间树上进行深度优先遍历，如果解决问题的步骤较多或者每个步骤都面临多个选项，那么时间复杂度将会极高，所以如果我们知道有些子树不需要遍历，那么就应该直接跳过这些情况，即剪枝操作</p>
<h2 id="回溯法的应用">回溯法的应用</h2>
<h3 id="集合的组合排列">集合的组合、排列</h3>
<p>回溯法经常用来求一个数组的子集（组合）和排列</p>
<p>子集：从一个包含<code>m</code>个元素的集合中挑选出<code>n</code>个元素（<span class="math inline">\(0\leq n\leq m\)</span>）形成一个子集，一个子集又可以称为一个组合，子集中元素相同只是顺序不同时当做同一个子集</p>
<p>排列：从一个包含<code>m</code>个元素的集合中挑选出<code>n</code>个元素（<span class="math inline">\(0\leq n\leq m\)</span>）按照某种顺序形成一个排列，如果两个排列元素相同但是顺序不同，当做是两个不同的排列</p>
<h4 id="所有子集">所有子集</h4>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>
<p>这道题我们可以发现，我们求子集可以通过遍历原数组的方式，对于每一个元素我可以选择与不选择，那么就是每个步骤有多种选择，很明显可以使用回溯法进行求解</p>
<p>我们遍历数组，对于每个元素，我可以加入子集也可以不加入子集，这样直到所有元素我都遍历过就终止并回溯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(nums,result,<span class="keyword">new</span> LinkedList&lt;&gt;(),<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; curSubSet ,<span class="keyword">int</span> curIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curIndex==nums.length)&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(curSubSet));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curIndex&lt;nums.length)&#123;</span><br><span class="line">        backTracking(nums,result,curSubSet,curIndex+<span class="number">1</span>);</span><br><span class="line">        curSubSet.add(nums[curIndex]);</span><br><span class="line">        backTracking(nums,result,curSubSet,curIndex+<span class="number">1</span>);</span><br><span class="line">        curSubSet.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含k个元素的组合">包含k个元素的组合</h4>
<blockquote>
<p>LeetCode 77</p>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这道题和上一题没有多大区别，区别就是终止条件是组合长度达到k，而不是之前的遍历完所有数组元素</p>
<p>所以只需要将上一题的终止条件改一下即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(n,k,<span class="number">1</span>,result,<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; combination)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(combination.size()==k)&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(combination));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;=n)&#123;</span><br><span class="line">        backTracking(n,k,i+<span class="number">1</span>,result,combination);</span><br><span class="line">        combination.add(i);</span><br><span class="line">        backTracking(n,k,i+<span class="number">1</span>,result,combination);</span><br><span class="line">        combination.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="允许重复选择元素的组合">允许重复选择元素的组合</h4>
<blockquote>
<p>LeetCode 39</p>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 &#x3D; 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure>
<p>这道题跟上面也是大同小异，只不过这道题可以选择重复的元素，所以我们还是遍历每个元素，每个元素也是选择与不选择的两个选项，但是选择了该元素后下一个状态还是可以选择该元素，只不过<code>target=target-candidates[i]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(candidates,target,<span class="number">0</span>,result,<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; combination)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(combination));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;<span class="number">0</span> &amp;&amp; i&lt;candidates.length)&#123;</span><br><span class="line">        backTracking(candidates,target,i+<span class="number">1</span>,result,combination);</span><br><span class="line">        combination.add(candidates[i]);</span><br><span class="line">        backTracking(candidates,target-candidates[i],i,result,combination);</span><br><span class="line">        combination.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含重复元素集合的组合">包含重复元素集合的组合</h4>
<blockquote>
<p>LeetCode 40</p>
<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>
<p><strong>注意：</strong>解集不能包含重复的组合。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这道题和上面的也是差不多的，区别就是集合中有重复元素但是我们输出的组合不能重复</p>
<p>如果我们不做处理，还是正常的回溯法，必然会有重复，例如<code>[2,2,2]</code>，回溯可能第一位不选，第二第三位都选，那么就是<code>[2,2]</code>，但是也可能是第一位第二位选，第三位不选，也是<code>[2,2]</code>，这就导致了重复</p>
<p>为了避免重复，我们可以先将数组排序，即一样的元素放到一起，然后对于例如<code>[2,2,2]</code>这种集合生成的组合，我们规定，如果选，必须先选第一位，再选第二位，再选第三位。我们用1表示选，0表示不选，以前的<code>[2,2]</code>可能是<code>[1,1,0],[1,0,1],[0,1,1]</code>，但是现在只能是<code>[1,1,0]</code>，这样规定就能有效避免重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(candidates,target,<span class="number">0</span>,result,<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; combination)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(combination));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;<span class="number">0</span> &amp;&amp; i&lt;candidates.length)&#123;</span><br><span class="line">        backTracking(candidates,target,getNext(candidates,i),result,combination);</span><br><span class="line">        combination.add(candidates[i]);</span><br><span class="line">        backTracking(candidates,target-candidates[i],i+<span class="number">1</span>,result,combination);</span><br><span class="line">        combination.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next = i;</span><br><span class="line">    <span class="keyword">while</span>(next&lt;candidates.length &amp;&amp; candidates[next]==candidates[i])&#123;</span><br><span class="line">        next ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="没有重复元素集合的全排列">没有重复元素集合的全排列</h4>
<blockquote>
<p>LeetCode 46</p>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>
<p>这道题是要生成排列问题，对于排列顺序就非常重要，所以我们初始状态选择应该是<code>1,2,3</code>三种情况，然后接下来每一步的选项都是没有被使用过的数字，终止条件就是所有数字都用到即可</p>
<p>清楚了每一步的选项和终止条件那么回溯也就非常容易了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; used = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        backTracking(nums,used,result,<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] nums, Set&lt;Integer&gt; used, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; permute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(permute.size()==nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(permute));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(permute.size()&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!used.contains(num))&#123;</span><br><span class="line">                    permute.add(num);</span><br><span class="line">                    used.add(num);</span><br><span class="line">                    backTracking(nums,used,result,permute);</span><br><span class="line">                    permute.removeLast();</span><br><span class="line">                    used.remove(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含重复元素集合的全排列">包含重复元素集合的全排列</h4>
<blockquote>
<p>LeetCode 47</p>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong><em>按任意顺序</em></strong> 返回所有不重复的全排列。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>
<p>这道题与上面的包含重复元素集合的组合类似，但是这道题是排列不是组合，还是有点不一样的</p>
<p>这道题的重点还是如何去保证排列不重复</p>
<p>我们还是可以先对原数组进行排序，使得一样的元素放在一起，然后创建一个<code>used</code>的数组，用于检查元素是否被使用</p>
<p>如下图所示，我们还是规定例如<code>[1,1,1]</code>这种元素，必须从前往后依次取，不可以第一个不取，取第二第三个，与之前的思路一致，这样每次遍历元素的时候，都比较一下自己前面有没有和自己相等但是没有使用过的，这种情况就直接剪枝掉即可</p>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230308190346.png" style="zoom: 80%;" /></p>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230308190632.png" style="zoom:80%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        backTracking(nums,used,result,<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; permute)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(permute.size()==nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(permute));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(permute.size()&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!(i!=<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) &amp;&amp; !used[i]) &#123;</span><br><span class="line">                    permute.add(nums[i]);</span><br><span class="line">                    used[i]=<span class="keyword">true</span>;</span><br><span class="line">                    backTracking(nums,used,result,permute);</span><br><span class="line">                    used[i]=<span class="keyword">false</span>;</span><br><span class="line">                    permute.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他类型问题">其他类型问题</h3>
<h4 id="生成匹配的括号">生成匹配的括号</h4>
<blockquote>
<p>LeetCode 22</p>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure>
<p>这道理我们可以发现，生成括号的过程可以看做很多步，每一步可以生成<code>(</code>或者<code>)</code>，很明显可以使用回溯法进行解题</p>
<p>那么我们寻找每次的选择的条件和终止的条件，可以发现左右括号最多只能是<code>n</code>个，并且右括号的个数大于等于左括号的时候只能选择左括号，这样回溯法的逻辑就出来啦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(n,n,result,<span class="keyword">new</span> StringBuilder());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span> leftCount, <span class="keyword">int</span> rightCount, List&lt;String&gt; result,StringBuilder sb)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(leftCount== <span class="number">0</span> &amp;&amp; rightCount==<span class="number">0</span>)&#123;</span><br><span class="line">        result.add(sb.toString());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftCount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">"("</span>);</span><br><span class="line">            backTracking(leftCount-<span class="number">1</span>,rightCount,result,sb);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftCount&lt;rightCount)&#123;</span><br><span class="line">            sb.append(<span class="string">")"</span>);</span><br><span class="line">            backTracking(leftCount,rightCount-<span class="number">1</span>,result,sb);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分割回文子字符串">分割回文子字符串</h4>
<blockquote>
<p>LeetCode 131</p>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>
<p>这道题我们还是可以用回溯的方法，我们先找每一步的策略</p>
<p>例如<code>"google"</code>，我们从<code>g</code>开始，先找到以<code>g</code>开头的回文串，发现<code>g</code>和<code>goog</code>，然后继续以下一个元素为首元素找回文字符串</p>
<p>所以每一步就是遍历剩余字符串，然后找到一个回文串即可，终止条件就是所有元素都遍历到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(s,<span class="number">0</span>,result,<span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(String s, <span class="keyword">int</span> start, List&lt;List&lt;String&gt;&gt; result, LinkedList&lt;String&gt; subStrings)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(start==s.length())&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(subStrings));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s,start,i))&#123;</span><br><span class="line">                subStrings.add(s.substring(start,i+<span class="number">1</span>));</span><br><span class="line">                backTracking(s,i+<span class="number">1</span>,result,subStrings);</span><br><span class="line">                subStrings.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(start++)!=s.charAt(end--))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="恢复ip地址">恢复IP地址</h4>
<blockquote>
<p>LeetCode 93</p>
<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p>
<ul>
<li>例如：<code>"0.1.2.201"</code> 和<code>"192.168.1.1"</code> 是 <strong>有效</strong> IP 地址，但是 <code>"0.011.255.245"</code>、<code>"192.168.1.312"</code> 和 <code>"192.168@1.1"</code> 是 <strong>无效</strong> IP 地址。</li>
</ul>
<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>
</blockquote>
<p>我们可以发现<code>IP</code>地址是由四个分段组成，而每个字符都有两种选择，加入当前分段或者称为新分段的开头，这种一步一步探测的就完全可以使用回溯法解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(s,<span class="number">0</span>,<span class="number">0</span>,<span class="string">""</span>,<span class="string">""</span>,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> segI, String seg, String ip, List&lt;String&gt; result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==s.length() &amp;&amp; segI==<span class="number">3</span> &amp;&amp; isValidSeg(seg))&#123;</span><br><span class="line">        result.add(ip+seg);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;s.length() &amp;&amp; segI&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(isValidSeg(seg+ch))&#123;</span><br><span class="line">            backTracking(s,i+<span class="number">1</span>,segI,seg+ch,ip,result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(seg.length()&gt;<span class="number">0</span> &amp;&amp; segI&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            backTracking(s,i+<span class="number">1</span>,segI+<span class="number">1</span>,<span class="string">""</span>+ch,ip+seg+<span class="string">"."</span>,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidSeg</span><span class="params">(String seg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(seg)&lt;=<span class="number">255</span> &amp;&amp; (seg.equals(<span class="string">"0"</span>) || seg.charAt(<span class="number">0</span>)!=<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="prev" title="动态规划">
      <i class="fa fa-chevron-left"></i> 动态规划
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#回溯法"><span class="nav-number">1.</span> <span class="nav-text">回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#回溯法的基础知识"><span class="nav-number">1.1.</span> <span class="nav-text">回溯法的基础知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回溯法的应用"><span class="nav-number">1.2.</span> <span class="nav-text">回溯法的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集合的组合排列"><span class="nav-number">1.2.1.</span> <span class="nav-text">集合的组合、排列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#所有子集"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">所有子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包含k个元素的组合"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">包含k个元素的组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#允许重复选择元素的组合"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">允许重复选择元素的组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包含重复元素集合的组合"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">包含重复元素集合的组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#没有重复元素集合的全排列"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">没有重复元素集合的全排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包含重复元素集合的全排列"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">包含重复元素集合的全排列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他类型问题"><span class="nav-number">1.2.2.</span> <span class="nav-text">其他类型问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成匹配的括号"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">生成匹配的括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分割回文子字符串"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">分割回文子字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#恢复ip地址"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">恢复IP地址</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wanghui Cai"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Wanghui Cai</p>
  <div class="site-description" itemprop="description">一些零零散散的学习总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bigmoom" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bigmoom" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:15850180970@163.com" title="E-Mail → mailto:15850180970@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="https://beian.miit.gov.cn/#/Integrated/index" rel="noopener" target="_blank">苏ICP备20010524 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wanghui Cai</span>
</div>




        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
