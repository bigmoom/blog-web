<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="google-site-verification" content="_i0mgfxBy6QPgJZLx5NbYfLAp5i5xqHoSKIcpYOPHM0" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_i0mgfxBy6QPgJZLx5NbYfLAp5i5xqHoSKIcpYOPHM0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.caiwanghui.top","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一些零零散散的学习总结">
<meta property="og:type" content="website">
<meta property="og:title" content="菜鸡肥肥的私人博客">
<meta property="og:url" content="http://www.caiwanghui.top/index.html">
<meta property="og:site_name" content="菜鸡肥肥的私人博客">
<meta property="og:description" content="一些零零散散的学习总结">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wanghui Cai">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.caiwanghui.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>菜鸡肥肥的私人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">菜鸡肥肥的私人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/03/08/%E5%9B%9E%E6%BA%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/08/%E5%9B%9E%E6%BA%AF%E6%B3%95/" class="post-title-link" itemprop="url">回溯法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-08 13:41:32 / 修改时间：12:55:34" itemprop="dateCreated datePublished" datetime="2023-03-08T13:41:32Z">2023-03-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="回溯法">回溯法</h1>
<h2 id="回溯法的基础知识">回溯法的基础知识</h2>
<p>回溯法可以看做是蛮力法的升级，它在解决问题的每一步都尝试祝所有可能的选项，最终找出所有可行的解决方案</p>
<p>所以回溯法特别适用于解决由多个步骤组成的问题，并且每个步骤都有多个选项。在某一步选择了其中一个选项之后进入到下一步并面临新的选项，直到到达最终的状态</p>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230308143936.png" style="zoom:67%;" /></p>
<p>例如我们这里想要获得根结点到叶子结点的所有路径，其实就类似于树的深度遍历</p>
<p>以上图为例，从根结点开始，只有结点2这个选项，所以选择2</p>
<p>到达结点2，现在有3个选项，我们先选择结点3，发现为叶子结点，即到达最终状态，输出<code>123</code></p>
<p>向上回溯，这里回溯与树的<code>dfs</code>不同的是，这里的回溯指的是回归到结点2的状态，即当作没有访问过结点3，继续访问结点4，那么照样输出<code>124</code>，如果这里不忘记结点3，那么正常的<code>DFS</code>的前序遍历，可能就会输出<code>1234</code>，这不是我们想要的</p>
<p>继续回溯，选择新的选项，到达结点5，输出<code>125</code></p>
<p>由于回溯法实在所有选项形成的解空间树上进行深度优先遍历，如果解决问题的步骤较多或者每个步骤都面临多个选项，那么时间复杂度将会极高，所以如果我们知道有些子树不需要遍历，那么就应该直接跳过这些情况，即剪枝操作</p>
<h2 id="回溯法的应用">回溯法的应用</h2>
<h3 id="集合的组合排列">集合的组合、排列</h3>
<p>回溯法经常用来求一个数组的子集（组合）和排列</p>
<p>子集：从一个包含<code>m</code>个元素的集合中挑选出<code>n</code>个元素（<span class="math inline">\(0\leq n\leq m\)</span>）形成一个子集，一个子集又可以称为一个组合，子集中元素相同只是顺序不同时当做同一个子集</p>
<p>排列：从一个包含<code>m</code>个元素的集合中挑选出<code>n</code>个元素（<span class="math inline">\(0\leq n\leq m\)</span>）按照某种顺序形成一个排列，如果两个排列元素相同但是顺序不同，当做是两个不同的排列</p>
<h4 id="所有子集">所有子集</h4>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>
<p>这道题我们可以发现，我们求子集可以通过遍历原数组的方式，对于每一个元素我可以选择与不选择，那么就是每个步骤有多种选择，很明显可以使用回溯法进行求解</p>
<p>我们遍历数组，对于每个元素，我可以加入子集也可以不加入子集，这样直到所有元素我都遍历过就终止并回溯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(nums,result,<span class="keyword">new</span> LinkedList&lt;&gt;(),<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; curSubSet ,<span class="keyword">int</span> curIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curIndex==nums.length)&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(curSubSet));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curIndex&lt;nums.length)&#123;</span><br><span class="line">        backTracking(nums,result,curSubSet,curIndex+<span class="number">1</span>);</span><br><span class="line">        curSubSet.add(nums[curIndex]);</span><br><span class="line">        backTracking(nums,result,curSubSet,curIndex+<span class="number">1</span>);</span><br><span class="line">        curSubSet.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含k个元素的组合">包含k个元素的组合</h4>
<blockquote>
<p>LeetCode 77</p>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这道题和上一题没有多大区别，区别就是终止条件是组合长度达到k，而不是之前的遍历完所有数组元素</p>
<p>所以只需要将上一题的终止条件改一下即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(n,k,<span class="number">1</span>,result,<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; combination)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(combination.size()==k)&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(combination));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;=n)&#123;</span><br><span class="line">        backTracking(n,k,i+<span class="number">1</span>,result,combination);</span><br><span class="line">        combination.add(i);</span><br><span class="line">        backTracking(n,k,i+<span class="number">1</span>,result,combination);</span><br><span class="line">        combination.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="允许重复选择元素的组合">允许重复选择元素的组合</h4>
<blockquote>
<p>LeetCode 39</p>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 &#x3D; 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure>
<p>这道题跟上面也是大同小异，只不过这道题可以选择重复的元素，所以我们还是遍历每个元素，每个元素也是选择与不选择的两个选项，但是选择了该元素后下一个状态还是可以选择该元素，只不过<code>target=target-candidates[i]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(candidates,target,<span class="number">0</span>,result,<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; combination)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(combination));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;<span class="number">0</span> &amp;&amp; i&lt;candidates.length)&#123;</span><br><span class="line">        backTracking(candidates,target,i+<span class="number">1</span>,result,combination);</span><br><span class="line">        combination.add(candidates[i]);</span><br><span class="line">        backTracking(candidates,target-candidates[i],i,result,combination);</span><br><span class="line">        combination.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含重复元素集合的组合">包含重复元素集合的组合</h4>
<blockquote>
<p>LeetCode 40</p>
<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>
<p><strong>注意：</strong>解集不能包含重复的组合。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这道题和上面的也是差不多的，区别就是集合中有重复元素但是我们输出的组合不能重复</p>
<p>如果我们不做处理，还是正常的回溯法，必然会有重复，例如<code>[2,2,2]</code>，回溯可能第一位不选，第二第三位都选，那么就是<code>[2,2]</code>，但是也可能是第一位第二位选，第三位不选，也是<code>[2,2]</code>，这就导致了重复</p>
<p>为了避免重复，我们可以先将数组排序，即一样的元素放到一起，然后对于例如<code>[2,2,2]</code>这种集合生成的组合，我们规定，如果选，必须先选第一位，再选第二位，再选第三位。我们用1表示选，0表示不选，以前的<code>[2,2]</code>可能是<code>[1,1,0],[1,0,1],[0,1,1]</code>，但是现在只能是<code>[1,1,0]</code>，这样规定就能有效避免重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(candidates,target,<span class="number">0</span>,result,<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; combination)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(combination));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;<span class="number">0</span> &amp;&amp; i&lt;candidates.length)&#123;</span><br><span class="line">        backTracking(candidates,target,getNext(candidates,i),result,combination);</span><br><span class="line">        combination.add(candidates[i]);</span><br><span class="line">        backTracking(candidates,target-candidates[i],i+<span class="number">1</span>,result,combination);</span><br><span class="line">        combination.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next = i;</span><br><span class="line">    <span class="keyword">while</span>(next&lt;candidates.length &amp;&amp; candidates[next]==candidates[i])&#123;</span><br><span class="line">        next ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="没有重复元素集合的全排列">没有重复元素集合的全排列</h4>
<blockquote>
<p>LeetCode 46</p>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>
<p>这道题是要生成排列问题，对于排列顺序就非常重要，所以我们初始状态选择应该是<code>1,2,3</code>三种情况，然后接下来每一步的选项都是没有被使用过的数字，终止条件就是所有数字都用到即可</p>
<p>清楚了每一步的选项和终止条件那么回溯也就非常容易了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; used = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        backTracking(nums,used,result,<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] nums, Set&lt;Integer&gt; used, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; permute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(permute.size()==nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(permute));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(permute.size()&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!used.contains(num))&#123;</span><br><span class="line">                    permute.add(num);</span><br><span class="line">                    used.add(num);</span><br><span class="line">                    backTracking(nums,used,result,permute);</span><br><span class="line">                    permute.removeLast();</span><br><span class="line">                    used.remove(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含重复元素集合的全排列">包含重复元素集合的全排列</h4>
<blockquote>
<p>LeetCode 47</p>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong><em>按任意顺序</em></strong> 返回所有不重复的全排列。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>
<p>这道题与上面的包含重复元素集合的组合类似，但是这道题是排列不是组合，还是有点不一样的</p>
<p>这道题的重点还是如何去保证排列不重复</p>
<p>我们还是可以先对原数组进行排序，使得一样的元素放在一起，然后创建一个<code>used</code>的数组，用于检查元素是否被使用</p>
<p>如下图所示，我们还是规定例如<code>[1,1,1]</code>这种元素，必须从前往后依次取，不可以第一个不取，取第二第三个，与之前的思路一致，这样每次遍历元素的时候，都比较一下自己前面有没有和自己相等但是没有使用过的，这种情况就直接剪枝掉即可</p>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230308190346.png" style="zoom: 80%;" /></p>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230308190632.png" style="zoom:80%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        backTracking(nums,used,result,<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; result, LinkedList&lt;Integer&gt; permute)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(permute.size()==nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(permute));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(permute.size()&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!(i!=<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) &amp;&amp; !used[i]) &#123;</span><br><span class="line">                    permute.add(nums[i]);</span><br><span class="line">                    used[i]=<span class="keyword">true</span>;</span><br><span class="line">                    backTracking(nums,used,result,permute);</span><br><span class="line">                    used[i]=<span class="keyword">false</span>;</span><br><span class="line">                    permute.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他类型问题">其他类型问题</h3>
<h4 id="生成匹配的括号">生成匹配的括号</h4>
<blockquote>
<p>LeetCode 22</p>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure>
<p>这道理我们可以发现，生成括号的过程可以看做很多步，每一步可以生成<code>(</code>或者<code>)</code>，很明显可以使用回溯法进行解题</p>
<p>那么我们寻找每次的选择的条件和终止的条件，可以发现左右括号最多只能是<code>n</code>个，并且右括号的个数大于等于左括号的时候只能选择左括号，这样回溯法的逻辑就出来啦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(n,n,result,<span class="keyword">new</span> StringBuilder());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span> leftCount, <span class="keyword">int</span> rightCount, List&lt;String&gt; result,StringBuilder sb)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(leftCount== <span class="number">0</span> &amp;&amp; rightCount==<span class="number">0</span>)&#123;</span><br><span class="line">        result.add(sb.toString());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftCount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">"("</span>);</span><br><span class="line">            backTracking(leftCount-<span class="number">1</span>,rightCount,result,sb);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftCount&lt;rightCount)&#123;</span><br><span class="line">            sb.append(<span class="string">")"</span>);</span><br><span class="line">            backTracking(leftCount,rightCount-<span class="number">1</span>,result,sb);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分割回文子字符串">分割回文子字符串</h4>
<blockquote>
<p>LeetCode 131</p>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>
<p>这道题我们还是可以用回溯的方法，我们先找每一步的策略</p>
<p>例如<code>"google"</code>，我们从<code>g</code>开始，先找到以<code>g</code>开头的回文串，发现<code>g</code>和<code>goog</code>，然后继续以下一个元素为首元素找回文字符串</p>
<p>所以每一步就是遍历剩余字符串，然后找到一个回文串即可，终止条件就是所有元素都遍历到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(s,<span class="number">0</span>,result,<span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(String s, <span class="keyword">int</span> start, List&lt;List&lt;String&gt;&gt; result, LinkedList&lt;String&gt; subStrings)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(start==s.length())&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(subStrings));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s,start,i))&#123;</span><br><span class="line">                subStrings.add(s.substring(start,i+<span class="number">1</span>));</span><br><span class="line">                backTracking(s,i+<span class="number">1</span>,result,subStrings);</span><br><span class="line">                subStrings.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(start++)!=s.charAt(end--))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="恢复ip地址">恢复IP地址</h4>
<blockquote>
<p>LeetCode 93</p>
<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p>
<ul>
<li>例如：<code>"0.1.2.201"</code> 和<code>"192.168.1.1"</code> 是 <strong>有效</strong> IP 地址，但是 <code>"0.011.255.245"</code>、<code>"192.168.1.312"</code> 和 <code>"192.168@1.1"</code> 是 <strong>无效</strong> IP 地址。</li>
</ul>
<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>
</blockquote>
<p>我们可以发现<code>IP</code>地址是由四个分段组成，而每个字符都有两种选择，加入当前分段或者称为新分段的开头，这种一步一步探测的就完全可以使用回溯法解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backTracking(s,<span class="number">0</span>,<span class="number">0</span>,<span class="string">""</span>,<span class="string">""</span>,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> segI, String seg, String ip, List&lt;String&gt; result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==s.length() &amp;&amp; segI==<span class="number">3</span> &amp;&amp; isValidSeg(seg))&#123;</span><br><span class="line">        result.add(ip+seg);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;s.length() &amp;&amp; segI&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(isValidSeg(seg+ch))&#123;</span><br><span class="line">            backTracking(s,i+<span class="number">1</span>,segI,seg+ch,ip,result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(seg.length()&gt;<span class="number">0</span> &amp;&amp; segI&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            backTracking(s,i+<span class="number">1</span>,segI+<span class="number">1</span>,<span class="string">""</span>+ch,ip+seg+<span class="string">"."</span>,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidSeg</span><span class="params">(String seg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(seg)&lt;=<span class="number">255</span> &amp;&amp; (seg.equals(<span class="string">"0"</span>) || seg.charAt(<span class="number">0</span>)!=<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/03/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-08 13:40:06" itemprop="dateCreated datePublished" datetime="2023-03-08T13:40:06Z">2023-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-09 13:34:51" itemprop="dateModified" datetime="2023-03-09T13:34:51Z">2023-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动态规划">动态规划</h1>
<h2 id="动态规划介绍">动态规划介绍</h2>
<p><strong>动态规划</strong>（英语：Dynamic programming，简称DP）是一种在<a href="https://zh.wikipedia.org/wiki/数学" target="_blank" rel="noopener">数学</a>、<a href="https://zh.wikipedia.org/wiki/管理科学" target="_blank" rel="noopener">管理科学</a>、<a href="https://zh.wikipedia.org/wiki/计算机科学" target="_blank" rel="noopener">计算机科学</a>、<a href="https://zh.wikipedia.org/wiki/经济学" target="_blank" rel="noopener">经济学</a>和<a href="https://zh.wikipedia.org/wiki/生物信息学" target="_blank" rel="noopener">生物信息学</a>中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
<p>上面是来及wiki的介绍，其实动态规划说起来很简单，就是将复杂问题分解为子问题去解决</p>
<p>我们知道分治法也是将大问题化为子问题去解决，例如快速排序，将排序分为基准值左边和基准值右边继续排序，但是这种划分子问题的情况是子问题不存在重叠的情况，即左子问题与右子问题互不干扰，但是动态规划的子问题是存在相互重叠的情况</p>
<p>求解动态规划问题的步骤其实很简单，主要就以下几步：</p>
<ul>
<li>确定状态</li>
<li>拆分子问题，确定状态转移方程</li>
<li>优化复杂度</li>
</ul>
<p>我们直接以下面例子进行说明</p>
<blockquote>
<p>LeetCode 746</p>
<p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cost &#x3D; [10,15,20]</span><br><span class="line">输出：15</span><br><span class="line">解释：你将从下标为 1 的台阶开始。</span><br><span class="line">- 支付 15 ，向上爬两个台阶，到达楼梯顶部。</span><br><span class="line">总花费为 15 。</span><br></pre></td></tr></table></figure>
<p>这道题是动态规划中非常非常经典的一道题</p>
<ul>
<li><p>确定状态</p>
<p>通过分析，我们可以从<span class="math inline">\(i\)</span>级台阶网上爬花费为一个状态<span class="math inline">\(f(i)\)</span></p></li>
<li><p>拆分子问题，确定状态转移方程</p>
<p>题目告诉我们从一个台阶可以一次爬一级或者两级，那么我第<span class="math inline">\(i\)</span>级的台阶的最小开销就是爬一级到达该台阶以及爬两级到达该台阶的花费的最小值加上该台阶向上爬的花销，即 <span class="math display">\[
f(i) = min(f(i-1),f(i-2)) + cost[i]
\]</span> 当然这里<span class="math inline">\(i\geq2\)</span>，因为题目中说了可以从下标0或者1的台阶开始爬，所以<span class="math inline">\(f(0)=cost[0],f(1)=cost[1]\)</span></p></li>
</ul>
<p>我们先不看如何优化，有了状态转移方程，我们就可以直接通过递归求解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = cost.length;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp(cost,length-<span class="number">1</span>),dp(cost,length-<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] cost, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp(cost,i-<span class="number">1</span>),dp(cost,i-<span class="number">2</span>))+cost[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法非常简单，但是时间复杂度极其糟糕，因为我们需要重复计算很多次的相同子问题，例如我要求<span class="math inline">\(f(10)\)</span>，必然要求<span class="math inline">\(f(9),f(8)\)</span>，然后递归求解的时候<span class="math inline">\(f(6),f(7)\)</span>等等都重复计算了，所以时间复杂度很糟糕，接下来就是我们对动态规划经常要做的就是<strong>优化复杂度</strong></p>
<ul>
<li><p>使用缓存的递归方法</p>
<p>正如我们上面说的，我们存在很多被重复计算的代码，那么我们可以使用一个数组记录子问题的值，如果已经算过那就直接取值不需要再进行计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = cost.length;</span><br><span class="line">    <span class="keyword">int</span>[] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length];</span><br><span class="line">    dpStatus[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dpStatus[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">    dp(cost,length-<span class="number">1</span>,dpStatus);</span><br><span class="line">    <span class="keyword">return</span> Math.min(dpStatus[length-<span class="number">1</span>],dpStatus[length-<span class="number">2</span>]);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] cost, <span class="keyword">int</span> i,<span class="keyword">int</span>[] dpStatus)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dpStatus[i]==<span class="number">0</span> &amp;&amp; i&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        dp(cost,i-<span class="number">1</span>,dpStatus);</span><br><span class="line">        dp(cost,i-<span class="number">2</span>,dpStatus);</span><br><span class="line">        dpStatus[i] = Math.min(dpStatus[i-<span class="number">1</span>],dpStatus[i-<span class="number">2</span>])+cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自下而上的迭代方法</p>
<p>上面的方法都是由大问题化解为小问题，是一种自顶向下的方法，我们也可以自下而上的通过子问题求解大问题，例如我们先通过<span class="math inline">\(f(0),f(1)\)</span>求出<span class="math inline">\(f(2)\)</span>，然后通过<span class="math inline">\(f(1),f(2)\)</span>求出<span class="math inline">\(f(3)\)</span>，依次向上直到达到顶部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = cost.length;</span><br><span class="line">    <span class="keyword">int</span>[] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    dpStatus[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dpStatus[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;length;++i)&#123;</span><br><span class="line">        dpStatus[i] = Math.min(dpStatus[i-<span class="number">2</span>],dpStatus[i-<span class="number">1</span>])+cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Math.min(dpStatus[length-<span class="number">1</span>],dpStatus[length-<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>空间复杂度为<span class="math inline">\(O(1)\)</span>的迭代方法</p>
<p>上面的方法其实很优了，但是我们还是可以进行优化</p>
<p>我们发现我们其实并不需要存储每个状态，我们要的只不过是前面两个状态，所以我们只需要构建一个长度为2的数组存储前两个状态即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = cost.length;</span><br><span class="line">    <span class="keyword">int</span>[] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cost[<span class="number">0</span>],cost[<span class="number">1</span>]&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;length;++i)&#123;</span><br><span class="line">        dpStatus[i%<span class="number">2</span>] = Math.min(dpStatus[<span class="number">0</span>],dpStatus[<span class="number">1</span>])+cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Math.min(dpStatus[<span class="number">0</span>],dpStatus[<span class="number">1</span>]);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="动态规划常见题型">动态规划常见题型</h2>
<h3 id="单序列问题">单序列问题</h3>
<p>应用动态规划解决单序列问题的关键在于每一步在序列中增加一个元素，根据题目的特点找出元素对应的最优解和前面若干元素的最优解的关系即状态转移方程</p>
<h4 id="房屋偷盗">房屋偷盗</h4>
<blockquote>
<p>LeetCode 198</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>我们以<span class="math inline">\(f(i)\)</span>表示到房屋<span class="math inline">\(i\)</span>能偷取的最大金额</p></li>
<li><p>确定状态转移方程</p>
<p>我们观察在房屋<span class="math inline">\(i\)</span>的时候，我们有两种可能，偷与不偷，如果偷的话，那么我们就不可能偷<span class="math inline">\(i-1\)</span>房屋，这个时候<span class="math inline">\(f(i)=f(i-2)+nums[i]\)</span>，即到达房屋<span class="math inline">\(i-2\)</span>的最大金额加上偷<span class="math inline">\(i\)</span>的金额，那么如果不偷，就可以到达房屋<span class="math inline">\(i-1\)</span>，所以<span class="math inline">\(f(i) = f(i-1)\)</span>，所以转移方程就是 <span class="math display">\[
f(i) = max((f(i-2)+nums[i]),f(i-1))
\]</span> 这里的<span class="math inline">\(i\geq2\)</span>,当<span class="math inline">\(i=0\)</span>的时候，直接偷，<span class="math inline">\(i=1\)</span>的时候，<span class="math inline">\(f(1) = max(nums[0],nums[1])\)</span></p></li>
</ul>
<p>确定了转移方程之后就可以直接写了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[<span class="number">0</span>],Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;++i)&#123;</span><br><span class="line">        dpStatus[i%<span class="number">2</span>] = Math.max((dpStatus[(i-<span class="number">2</span>)%<span class="number">2</span>])+nums[i],dpStatus[(i-<span class="number">1</span>)%<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dpStatus[(len-<span class="number">1</span>)%<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上一题没差，都是可以只使用长度为2的数组存储前两个状态</p>
<p><strong>双状态转移方程</strong></p>
<p>这道题我们还可以通过两个状态转移方程来解决</p>
<p>我们将到达<span class="math inline">\(i\)</span>的状态分为偷与不偷，不偷的最大金额为<span class="math inline">\(f(i)\)</span>，偷的最大金额为<span class="math inline">\(g(i)\)</span>，那么<span class="math inline">\(i\)</span>状态能偷到的最大金额为<span class="math inline">\(max(f(i),g(i))\)</span>，接下来我们就要看关于<span class="math inline">\(f(i),g(i)\)</span>的状态转移方程</p>
<p>对于<span class="math inline">\(i\)</span>不偷，那么他不管进不进入<span class="math inline">\(i-1\)</span>，都不会触发报警，所以状态转移方程为： <span class="math display">\[
f(i) = max(f(i-1),g(i-1))
\]</span> 那么对于<span class="math inline">\(i\)</span>偷，对于<span class="math inline">\(i-1\)</span>只能不偷，所以状态转移方程为： <span class="math display">\[
g(i) = f(i-1)+nums[i]
\]</span> 那么有了状态转移方程，就可以直接开始写了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preF = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> preG = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempF = Math.max(preF,preG);</span><br><span class="line">        <span class="keyword">int</span> tempG = preF+nums[i];</span><br><span class="line">        preF = tempF;</span><br><span class="line">        preG = tempG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(preF,preG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="环形房屋偷盗">环形房屋偷盗</h4>
<blockquote>
<p>LeetCode 213</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<p>这道题和上面一题的区别就是这次的房屋形成了环，这个唯一的区别就是如果我偷了下标为0的房子，肯定不能偷最后的房子，如果没有偷下标为0的房子，那我就可以偷最后的房子</p>
<p>所以题目可以先转化为两个子问题，即偷下标<span class="math inline">\(0\to n-2\)</span>的房子和偷<span class="math inline">\(1\to n-1\)</span>的房子，然后对于每个子问题，就是上面的无环的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums.length==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(dp(nums,<span class="number">0</span>,length-<span class="number">2</span>),dp(nums,<span class="number">1</span>,length-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = start%<span class="number">2</span>==<span class="number">0</span>?<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[start],Math.max(nums[start],nums[start+<span class="number">1</span>])&#125;:<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Math.max(nums[start],nums[start+<span class="number">1</span>]),nums[start]&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">2</span>;i&lt;=end;++i)&#123;</span><br><span class="line">        dp[i%<span class="number">2</span>] = Math.max(dp[(i-<span class="number">1</span>)%<span class="number">2</span>],(dp[(i-<span class="number">2</span>)%<span class="number">2</span>]+nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[end%<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="粉刷房子">粉刷房子</h4>
<blockquote>
<p>LeetCode 256</p>
<p>假如有一排房子，共 <code>n</code> 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p>
<p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 <code>n x 3</code> 的正整数矩阵 <code>costs</code> 来表示的。</p>
<p>例如，<code>costs[0][0]</code> 表示第 0 号房子粉刷成红色的成本花费；<code>costs[1][2]</code> 表示第 1 号房子粉刷成绿色的花费，以此类推。</p>
<p>请计算出粉刷完所有房子最少的花费成本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: costs &#x3D; [[17,2,17],[16,16,5],[14,3,19]]</span><br><span class="line">输出: 10</span><br><span class="line">解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。</span><br><span class="line">     最少花费: 2 + 5 + 3 &#x3D; 10。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>对于每个房子我们可以涂三种颜色，所以可以设涂不同颜色的最小花费<span class="math inline">\(r(i),g(i),b(i)\)</span></p></li>
<li><p>确定状态转移方程</p>
<p>题目中限定了连续房子颜色不能相同，所以如果房子涂红色，那么前面房子只能涂蓝色或者绿色，我们取最小开销加上涂红色的开销就是当前房子涂红色的最小开销，同理其他颜色，所以我们就可以得到如下状态转移方程： <span class="math display">\[
r(i) = min(g(i-1),b(i-1))+cost[r][i]
\]</span></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = costs.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> preR = costs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> preB = costs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> preG = costs[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(preB,preG),preR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempR = Math.min(preG,preB)+costs[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> tempG = Math.min(preR,preB)+costs[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> tempB = Math.min(preR,preG)+costs[i][<span class="number">1</span>];</span><br><span class="line">        preR = tempR;</span><br><span class="line">        preG = tempG;</span><br><span class="line">        preB = tempB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(Math.min(preB,preG),preR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于只需要用到上一步的开销，所以不需要使用数组进行存储</p>
<h4 id="翻转字符">翻转字符</h4>
<blockquote>
<p>LeetCode 926</p>
<p>如果一个二进制字符串，是以一些 <code>0</code>（可能没有 <code>0</code>）后面跟着一些 <code>1</code>（也可能没有 <code>1</code>）的形式组成的，那么该字符串是 <strong>单调递增</strong> 的。</p>
<p>给你一个二进制字符串 <code>s</code>，你可以将任何 <code>0</code> 翻转为 <code>1</code> 或者将 <code>1</code> 翻转为 <code>0</code> 。</p>
<p>返回使 <code>s</code> 单调递增的最小翻转次数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;00110&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：翻转最后一位得到 00111.</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>我们可以发现字符串中字符要么是0要么是1，所以我们把问题拆分为最后一位是0的最小翻折次数<span class="math inline">\(f(i)\)</span>和最后一位是1的最小翻折次数<span class="math inline">\(g(i)\)</span>，两者取最小值即可以得到总的最小值</p></li>
<li><p>确定状态转移方程，对于字符<span class="math inline">\(i\)</span>，对于翻折有多种可能</p>
<ul>
<li><p><span class="math inline">\(i=0\)</span>，如果不翻转即还是为0，那么<span class="math inline">\(i-1\)</span>只能是0，所以 <span class="math display">\[
f(i)=f(i-1)
\]</span> 如果翻转为1 <span class="math display">\[
g(i)=min(f(i-1),g(i-1))+1
\]</span></p></li>
<li><p><span class="math inline">\(i=1\)</span>，如果翻转，即0，那么前一位也肯定是0 <span class="math display">\[
f(i) = f(i-1)+1
\]</span> 不翻转 <span class="math display">\[
g(i)=min(f(i-1),g(i-1))
\]</span></p></li>
</ul></li>
</ul>
<p>得到状态转移方程之后就很简单了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFlipsMonoIncr</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> preF;</span><br><span class="line">    <span class="keyword">int</span> preG;</span><br><span class="line">    <span class="keyword">if</span>(s.charAt(<span class="number">0</span>)==<span class="string">'0'</span>)&#123;</span><br><span class="line">        preF = <span class="number">0</span>;</span><br><span class="line">        preG = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        preF = <span class="number">1</span>;</span><br><span class="line">        preG = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempF;</span><br><span class="line">        <span class="keyword">int</span> tempG;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">'0'</span>)&#123;</span><br><span class="line">            tempF = preF;</span><br><span class="line">            tempG = Math.min(preF,preG)+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tempF = preF +<span class="number">1</span>;</span><br><span class="line">            tempG = Math.min(preF,preG);</span><br><span class="line">        &#125;</span><br><span class="line">        preF = tempF;</span><br><span class="line">        preG = tempG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(preF,preG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长斐波那契数列">最长斐波那契数列</h4>
<blockquote>
<p>LeetCode 873</p>
<p>如果序列 <code>X_1, X_2, ..., X_n</code> 满足下列条件，就说它是 <em>斐波那契式</em> 的：</p>
<ul>
<li><code>n &gt;= 3</code></li>
<li>对于所有 <code>i + 2 &lt;= n</code>，都有 <code>X_i + X_{i+1} = X_{i+2}</code></li>
</ul>
<p>给定一个<strong>严格递增</strong>的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。</p>
<p><em>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， <code>[3, 5, 8]</code> 是 <code>[3, 4, 5, 6, 7, 8]</code> 的一个子序列）</em></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: arr &#x3D; [1,2,3,4,5,6,7,8]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>这道题的状态有点难找，我们以上面的实例来看</p>
<p>我们要找以8结尾的斐波那契式，我们可以看到倒数第二个数为7的时候，存在1使得斐波那契式成立，倒数第二个数为6的时候，存在2，倒数第二个数为5的时候，有<code>[1,2,3,5]</code>前置斐波那契式。。。</p>
<p>所以我们可以发现，我们斐波那契数的后面两个数为状态，即<span class="math inline">\(f(i,j)\)</span>，表示以<span class="math inline">\(i\)</span>为最后一位，<span class="math inline">\(j\)</span>为倒数第二位的斐波那契式的最长长度</p></li>
<li><p>确定状态转移方程</p>
<p>我们可以发现，确定<span class="math inline">\(i,j\)</span>之后，我们寻找有没有一个数<span class="math inline">\(k\)</span>使得<span class="math inline">\(arr[k]+arr[j]=arr[j]\)</span>，如果存在就 <span class="math display">\[
f(i,j) = f(j,k)+1
\]</span></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        indexMap.put(arr[i],i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = indexMap.getOrDefault(arr[i]-arr[j],-<span class="number">1</span>);</span><br><span class="line">            dpStatus[i][j] = k&gt;=<span class="number">0</span> &amp;&amp; k&lt;j?dpStatus[j][k]+<span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            result = Math.max(result,dpStatus[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result&gt;<span class="number">2</span>?result:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最少回文分割">最少回文分割</h4>
<blockquote>
<p>LeetCode 132</p>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aab&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：只需一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>这道题状态其实很好确定，就是设到达字符<span class="math inline">\(i\)</span>的时候最少分割次数为<span class="math inline">\(f(i)\)</span></p></li>
<li><p>确定状态转移方程</p>
<p>我们以字符<span class="math inline">\(i\)</span>寻找如何确定他的最少分割次数，首先，从<span class="math inline">\(0\to i\)</span>构成的字符是回文字符串，那么<span class="math inline">\(f(i)=0\)</span>，如果不是，那么我们就往前找，找看哪个字符<span class="math inline">\(j\)</span>，<span class="math inline">\(j\to i\)</span>构成字符为回文字符串，这个时候只需要再切割一次就可以，但是这并不是唯一能构成回文字符串的字符，我们要遍历前面所有字符串，寻找到最小分割次数而且能形成回文字符串的字符，所以状态转移方程就是 <span class="math display">\[
f(i) = min(f(j))+1
\]</span></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] isPal = <span class="keyword">new</span> <span class="keyword">boolean</span>[length][length];</span><br><span class="line">    <span class="keyword">int</span>[] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> ch2 = s.charAt(j);</span><br><span class="line">            <span class="keyword">if</span>(ch1==ch2 &amp;&amp; (i&lt;=j+<span class="number">1</span> || isPal[j+<span class="number">1</span>][i-<span class="number">1</span>]))&#123;</span><br><span class="line">                isPal[j][i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPal[<span class="number">0</span>][i])&#123;</span><br><span class="line">            dpStatus[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dpStatus[i] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isPal[j][i])&#123;</span><br><span class="line">                    dpStatus[i] = Math.min(dpStatus[i],dpStatus[j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dpStatus[length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码对判断回文字符串进行了优化，不用每次使用双指针进行遍历，判断的条件可以转换为</p>
<p>判断<span class="math inline">\(S[j\to i]\)</span>是不是回文字符串，只需要判断<span class="math inline">\(S[j]=S[i]\)</span>并且<span class="math inline">\(S[j+1\to i-1]\)</span>是回文字符串即可</p>
<h3 id="双序列问题">双序列问题</h3>
<h4 id="最长公共子序列">最长公共子序列</h4>
<blockquote>
<p>LeetCode 1143</p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但 <code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定状态</p>
<p>我们可以直接用<span class="math inline">\(f(i,j)\)</span>表明第一个字符串<span class="math inline">\(0\to i\)</span>和第二个字符串<span class="math inline">\(0\to j\)</span>这两个子串的最长公共子序列</p></li>
<li><p>确定状态转移方程</p>
<p>观察发现，当<span class="math inline">\(i,j\)</span>两个字符相等的时候，最长子序列为<span class="math inline">\(f(i-1,j-1)\)</span>加1</p>
<p>而当两个字符不相等的时候，说明不能同时在子序列中加上末尾的元素，俺么最长子序列即为<span class="math inline">\(f(i-1,j)\)</span>和<span class="math inline">\(f(i,j-1)\)</span>中的最大值</p>
<p>所以状态转移方程为： $$ f(i,j)=</p>
<span class="math display">\[\begin{cases}
f(i-1,j-1)+1,s1[i]==s2[j]\\
max(f(i-1,j),f(i,j-1)),s1[i]\not=s2[j]

\end{cases}\]</span>
<p>$$</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len1&lt;len2)&#123;</span><br><span class="line">        <span class="keyword">return</span> longestCommonSubsequence(text2,text1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dpStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][len2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len2;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1.charAt(i)==text2.charAt(j))&#123;</span><br><span class="line">                dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j+<span class="number">1</span>] = dpStatus[i%<span class="number">2</span>][j]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j+<span class="number">1</span>] = Math.max(dpStatus[(i+<span class="number">1</span>)%<span class="number">2</span>][j],dpStatus[i%<span class="number">2</span>][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpStatus[len1%<span class="number">2</span>][len2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码我们只使用了两行的二维数组存储状态，因为我们发现求<span class="math inline">\(f(i,j)\)</span>的时候只需要使用<span class="math inline">\(f(i-1,j-1),f(i-1,j),f(i,j-1)\)</span>周围三个，只需要两行即可</p>
<p>当然更优化的只需要一个一维数组即可，这边就不写了</p>
<h3 id="矩阵路径问题">矩阵路径问题</h3>
<h3 id="背包问题">背包问题</h3>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/03/05/%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/05/%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-04 19:18:17" itemprop="dateCreated datePublished" datetime="2023-03-04T19:18:17Z">2023-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-07 11:34:16" itemprop="dateModified" datetime="2023-03-07T11:34:16Z">2023-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="排序">排序</h1>
<p>排序是非常常见也是非常重要的一个考点，我们需要掌握不同的排序算法，以及这些排序算法之间的优劣之处</p>
<h2 id="排序的评价维度">排序的评价维度</h2>
<p>排序算法的评价维度主要有四类：<strong>稳定性，就地性，自适应性，比较类</strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/05/%E6%8E%92%E5%BA%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/03/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">二分查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-04 19:18:09" itemprop="dateCreated datePublished" datetime="2023-03-04T19:18:09Z">2023-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-06 06:06:30" itemprop="dateModified" datetime="2023-03-06T06:06:30Z">2023-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="二分查找">二分查找</h1>
<h2 id="二分查找的基础知识">二分查找的基础知识</h2>
<p>我们都知道在一个数组中搜索都是逐一搜索，时间复杂度很明显是<span class="math inline">\(O(N)\)</span></p>
<p>但是，如果一个数组是排好序的，那么我们就可以采用二分查找的方式进行优化</p>
<ul>
<li>取出数组最中间的元素进行比较，如果与目标数字相等就找到了</li>
<li>如果中间元素比目标元素小，说明目标元素在后半段数组，对后半段数组再进行二分查找</li>
<li>同理，如果中间元素比目标元素大，对前半段数组再进行二分查找</li>
<li>重复二分查找直到找到目标元素</li>
</ul>
<p>很显然，二分查找的时间复杂度为<span class="math inline">\(O(logN)\)</span></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/03/05/%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/05/%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-04 19:00:51" itemprop="dateCreated datePublished" datetime="2023-03-04T19:00:51Z">2023-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-05 13:04:20" itemprop="dateModified" datetime="2023-03-05T13:04:20Z">2023-03-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字符串">字符串</h1>
<h2 id="字符串的基本知识">字符串的基本知识</h2>
<p>字符串是由任意长度（长度可能为0）的字符组成，是编程语言中表示文本的数据类型，<code>JAVA</code>中使用<code>String</code>来表示字符串，与其他原因有不小的区别</p>
<h3 id="string的不可变性">String的不可变性</h3>
<p><code>JAVA</code>中<code>String</code>设计为不可变类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br></pre></td></tr></table></figure>
<p>上面代码其实就是<code>String</code>存储字符的变量，可以发现是一个<code>final</code>不可变属性，这样设计的原因有三点</p>
<ul>
<li>字符串常量池的需要：字符串常量池是 <code>Java</code> 堆内存中⼀个特殊的存储区域, 当创建⼀个 <code>String</code> 对象时，假如 此字符串值已经存在于常量池中，则不会创建⼀个新的对象，⽽是引⽤已经存在的对象；</li>
<li>允许 <code>String</code> 对象缓存 <code>HashCode</code>：<code>Java</code> 中 <code>String</code> 对象的哈希码被频繁地使⽤, ⽐如在 <code>HashMap</code> 等容器中。 字符串不变性保证了 <code>hash</code> 码的唯⼀性，因此可以放⼼地进⾏缓存。这也是⼀种性能优化⼿段，意味着不必每次都 去计算新的哈希码；</li>
<li><code>String</code> 被许多的 <code>Java</code> 类(库)⽤来当做参数，例如：⽹络连接地址 <code>URL</code>、⽂件路径 <code>path</code>、还有反射机制所需要 的 <code>String</code> 参数等, 假若 <code>String</code> 不是固定不变的，将会引起各种安全隐患。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/05/%E5%AD%97%E7%AC%A6%E4%B8%B2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/03/01/%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/01/%E5%9B%BE/" class="post-title-link" itemprop="url">图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-01 11:08:01" itemprop="dateCreated datePublished" datetime="2023-03-01T11:08:01Z">2023-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-04 10:56:17" itemprop="dateModified" datetime="2023-03-04T10:56:17Z">2023-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>33 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="图">图</h1>
<h2 id="图的基本知识">图的基本知识</h2>
<blockquote>
<p>相关图片来自<a href="https://www.hello-algo.com/chapter_graph/graph/#911" target="_blank" rel="noopener">Hello算法</a></p>
</blockquote>
<p>图是一种非常重要且常见的数据结构，通常用来表示物与物之间的关系，如果两个物之间存在某种关系，则在图中对应的结点存在边相连。</p>
<p>图由顶点（Vertex）和边（Edge）构成，所以我们可以将图<code>G</code>表示成一组顶点<code>V</code>和一组边<code>E</code>的集合</p>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123254.png" style="zoom: 80%;" /></p>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230301123316.png" /></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/01/%E5%9B%BE/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/02/28/%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%A0%86/" class="post-title-link" itemprop="url">堆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-28 13:58:33 / 修改时间：12:48:14" itemprop="dateCreated datePublished" datetime="2023-02-28T13:58:33Z">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="堆">堆</h1>
<h2 id="堆的基础知识">堆的基础知识</h2>
<p>堆是一种经常使用的数据结构，最多使用的就是大顶堆和小顶堆，他可以保证数据的局部有序，而避免全局有序的大量开销。在大顶堆中，保证每个节点的值总是大于或者等于任意子结点的值，小顶堆中，保证每个节点的值总是小于任意子结点的值。</p>
<blockquote>
<p>我们这里提到并且使用的堆都是普通二叉堆，其他的类似左式堆，d-堆，二项队列等都暂不介绍</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/02/28/%E5%A0%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/02/26/%E6%95%A3%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/%E6%95%A3%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">散列表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-25 20:27:45" itemprop="dateCreated datePublished" datetime="2023-02-25T20:27:45Z">2023-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-28 06:24:13" itemprop="dateModified" datetime="2023-02-28T06:24:13Z">2023-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="散列表">散列表</h1>
<h2 id="散列表的基础知识">散列表的基础知识</h2>
<p>散列表是一种非常常见的数据结构，最大的优点就是插入，删除和查找一个元素都只需要<span class="math inline">\(O(1)\)</span>的时间复杂度，所以哈希表通常被用来以空间换时间，优化时间效率。而哈希的基本思想就是散列，即将不同的关键字映射到不同的存储单元中。</p>
<h3 id="散列函数">散列函数</h3>
<p>散列函数即<code>hashCode()</code>，用来不同的关键字如何进行映射。</p>
<p>例如简单的对整数进行散列，即取模计算 <span class="math display">\[
key\space mode \space tableSize
\]</span>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/02/26/%E6%95%A3%E5%88%97%E8%A1%A8/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/02/09/%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/09/%E6%A0%91/" class="post-title-link" itemprop="url">树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-09 15:23:11" itemprop="dateCreated datePublished" datetime="2023-02-09T15:23:11Z">2023-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-25 08:11:29" itemprop="dateModified" datetime="2023-02-25T08:11:29Z">2023-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="树">树</h1>
<h2 id="树的基础知识">树的基础知识</h2>
<p>树是一种非常常见也非常重要的数据结构，下图所示就是一个普通的树：</p>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230209161254.png" style="zoom:67%;" /></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/02/09/%E6%A0%91/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.caiwanghui.top/2023/02/08/%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wanghui Cai">
      <meta itemprop="description" content="一些零零散散的学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸡肥肥的私人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/08/%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 19:52:56" itemprop="dateCreated datePublished" datetime="2023-02-07T19:52:56Z">2023-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-09 08:28:49" itemprop="dateModified" datetime="2023-02-09T08:28:49Z">2023-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="队列">队列</h1>
<h2 id="队列的基础知识">队列的基础知识</h2>
<p>队列是一种非常常见的数据结构，他的核心特点就是<code>FIFO</code>，<strong>先进先出</strong>。</p>
<p>栈可以分很多的种类</p>
<p><img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20230207195702.png" style="zoom:50%;" /></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/02/08/%E9%98%9F%E5%88%97/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wanghui Cai"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Wanghui Cai</p>
  <div class="site-description" itemprop="description">一些零零散散的学习总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bigmoom" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bigmoom" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:15850180970@163.com" title="E-Mail → mailto:15850180970@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="https://beian.miit.gov.cn/#/Integrated/index" rel="noopener" target="_blank">苏ICP备20010524 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wanghui Cai</span>
</div>




        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
